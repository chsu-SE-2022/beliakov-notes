# Задание:
Даны два стека целых чисел. Сфоpмиpовать очеpедь из элементов пеpвого стека, кpатных минимуму втоpого.
# Код:
## Массивами
```rust
#![feature(vec_push_within_capacity)]  
use rand;  
use rand::{random, Rng};  
#[derive(Debug)]  
struct Stack {  
    top: i32,  
    data: Vec<Option<i32>>  
}  
impl Stack {  
    fn new(capacity: u32) -> Self {  
        let top = -1;  
        let data: Vec<Option<i32>> = Vec::with_capacity(capacity as usize);  
        Stack {  
            top,  
            data  
        }  
    }    fn push(&mut self, value: i32) {  
        self.data.push_within_capacity(Some(value)).expect("TODO: panic message");  
        self.top += 1;  
    }    fn pop(&mut self) -> i32 {  
        self.top -= 1;  
        self.data.pop().unwrap().unwrap()  
    }    fn null_stack(&mut self) {  
        self.top = -1;  
        self.data.fill(None);  
    }    fn empty(&self) -> bool {  
        self.data.is_empty()  
    }    fn print(&self) -> String {  
        let mut str: String = String::default();  
        let mut top = self.top;  
        while top >= 0 {  
            str += &self.data.clone()[top as usize].expect("a").to_string();  
            str += " ";  
            top -= 1;  
        }        // for i in &self.data {  
        //     str += &i.clone().unwrap().to_string();        //     str += &" ";        // }        str  
    }  
}  
  
struct Queue {  
    data: Vec<Option<i32>>,  
}  
impl Queue {  
    fn new() -> Self {  
        Queue {  
            data: Vec::new()  
        }    }    fn enqueue(&mut self, value: i32) {  
        self.data.push(Some(value));  
    }    fn dequeue(&mut self) -> Result<i32, &str> {  
        if !self.data.is_empty() {  
            Ok(self.data.remove(0).unwrap())  
        }        else {  
            Err("queue is empty")  
        }    }    fn print(&self) -> String {  
        let mut str = String::default();  
        for i in &self.data {  
            str += &i.clone().unwrap().to_string();  
            str += &" ";  
        }        str  
    }  
    fn null_queue(&mut self) {  
        while !self.data.is_empty() {  
            self.data.remove(0);  
        }    }}  
  
fn main() {  
    let size_1: i32 = rand::thread_rng().gen_range(1..20);  
    let mut stack_1: Stack = Stack::new(size_1 as u32);  
    for _ in 1..size_1 {  
        stack_1.push((random::<u32>() % 100 + 1) as i32);  
    }    let size_2: i32 = rand::thread_rng().gen_range(1..20);  
    let mut stack_2: Stack = Stack::new(size_2 as u32);  
    for _ in 1..size_2 {  
        stack_2.push((random::<u32>() % 100 + 1) as i32);  
    }    let print1 = stack_1.print();  
    println!("Stack 1: {}", print1);  
    let print2 = stack_2.print();  
    println!("Stack 2: {}", print2);  
  
  
    let mut queue: Queue = Queue::new();  
  
    // finding minimum  
    let mut min: i32 = i32::MAX;  
    while !stack_2.empty() {  
        let temp = stack_2.pop();  
        if temp < min {  
            min = temp  
        }  
    }    println!("Min: {}", min);  
  
    while !stack_1.empty() {  
        let i = stack_1.pop();  
        if min != 0 && i % min == 0 {  
            queue.enqueue(i);  
        }    }    let print3 = queue.print();  
    println!("Queue: {}", print3);  
}
```
### Тесты
1.
```
Stack 1: 44 96 2 86 45 7 8 63 52 21 76 89 59 98 50 52 16 
Stack 2: 21 72 5 43 38 78 
Min: 5
Queue: 45 50 
```
2.
```
Stack 1: 12 83 62 56 96 61 9 69 31 46 68 67 41 49 30 28 51 
Stack 2: 100 
Min: 100
Queue:
```
3.
```
Stack 1: 53 50 32 53 8 56 64 8 24 60 1 51 67 49 
Stack 2: 77 30 41 54 16 78 90 74 26 25 2 34 85 
Min: 2
Queue: 50 32 8 56 64 8 24 60
```
## Списками
```rust
use std::ptr;  
use rand::{random, Rng};  
  
#[derive(Debug)]  
  
pub struct StackList {  
    head: StackLink,  
}  
  
type StackLink = Option<Box<StackNode>>;  
  
#[derive(PartialEq, Debug)]  
struct StackNode {  
    elem: i32,  
    next: StackLink,  
}  
impl StackList {  
    pub fn new() -> Self {  
        StackList { head: None }  
    }  
    pub fn push(&mut self, elem: i32) {  
        let new_node = Box::new(StackNode {  
            elem,  
            next: self.head.take(),  
        });  
        self.head = Some(new_node);  
    }  
    pub fn pop(&mut self) -> Option<i32> {  
        self.head.take().map(|node| {  
            self.head = node.next;  
            node.elem  
        })  
    }    fn print(&self) -> String {  
        let mut str: String = String::default();  
        let mut node = &self.head;  
        loop {  
            if node.is_some() {  
                print!("{:?} ", node.as_ref().unwrap().elem);  
                node = &node.as_ref().unwrap().next;  
            } else {  
                break  
            }  
        }        str  
    }  
    pub fn empty(&mut self) -> bool {  
        self.head == None  
    }  
}  
  
impl Drop for StackList {  
    fn drop(&mut self) {  
        let mut cur_link = self.head.take();  
        while let Some(mut boxed_node) = cur_link {  
            cur_link = boxed_node.next.take();  
        }    }}  
#[derive(Debug)]  
pub struct QueueList {  
    head: QueueLink,  
    tail: *mut QueueNode,  
}  
type QueueLink = *mut QueueNode;  
struct QueueNode {  
    elem: i32,  
    next: QueueLink,  
}  
impl QueueList {  
    pub fn new() -> Self {  
        QueueList { head: ptr::null_mut(), tail: ptr::null_mut() }  
    }    pub fn enqueue(&mut self, elem: i32) {  
        unsafe {  
            let new_tail = Box::into_raw(Box::new(QueueNode {  
                elem: elem,  
                next: ptr::null_mut(),  
            }));  
            if !self.tail.is_null() {  
                (*self.tail).next = new_tail;  
            } else {  
                self.head = new_tail;  
            }  
            self.tail = new_tail;  
        }    }    pub fn dequeue(&mut self) -> Option<i32> {  
        unsafe {  
            if self.head.is_null() {  
                None  
            } else {  
                let head = Box::from_raw(self.head);  
                self.head = head.next;  
  
                if self.head.is_null() {  
                    self.tail = ptr::null_mut();  
                }  
                Some(head.elem)  
            }        }    }    pub unsafe fn print(&mut self) -> String {  
        let mut str: String = String::default();  
        let mut head = self.head;  
        while (*head).next.as_ref().is_some() {  
            str += &(*head).elem.clone().to_string();  
            str += " ";  
            head = (*head).next;  
        }        str  
    }  
    fn empty(&self) -> bool {  
        self.head.is_null()  
    }}  
  
fn main() {  
    let mut stack_1 = StackList::new();  
    let size_1: i32 = rand::thread_rng().gen_range(2..20);  
    for _ in 1..size_1 {  
        stack_1.push((random::<u32>() % 100 + 1) as i32);  
    }    println!("{}", stack_1.print());  
    let mut stack_2 = StackList::new();  
    let size_2: i32 = rand::thread_rng().gen_range(2..20);  
    for _ in 1..size_2 {  
        stack_2.push((random::<u32>() % 100 + 1) as i32);  
    }    println!("{}", stack_2.print());  
    let mut queue = QueueList::new();  
    let mut min: i32 = i32::MAX;  
    while !stack_2.empty() {  
        let temp = stack_2.pop().unwrap();  
        if temp < min {  
            min = temp  
        }  
    }    while !stack_1.empty() {  
        let i = stack_1.pop().unwrap();  
        if min != 0 && i % min == 0 {  
            queue.enqueue(i);  
        }    }    println!("Min: {}", min);  
    let print3 = unsafe { queue.print() };  
    println!("{}", print3);  
  
  
}
```
### Тесты
1.
```
Stack 1: 52 7 4 70 90 44 18 14 45 84 
Stack 2: 10 99 13 
Min: 10
Queue: 70 
```
2.
```
Stack 1:  19 67 30 18 39 70 
Stack 2:  5 26 23 60 30 48 97 34 82 50 20 24 17 79 68 
Min: 5
Queue: 30 
```
3.
```
Stack 1:  25 10 64 
Stack 2:  49 84 64 97 86 92 82 19 20 28 55 23 3 71 30 91 92 
Min: 3
```
# Принцип
1. Объявляем два стека, заполняем их случайными значениями
2. Объявляем пустую очередь
3. Вычисляем минимальное значение внутри второго стека, получая значения функцией `pop` сравнивая их с `min`, если значение меньше `min`, присваиваем `min` это значение
4. Пока первый стек не пуст, функцией `pop` забираем значения из стека, проверяем на кратность с полученным `min`
5. Если число кратно, добавляем его в очередь функцией `enqueue`
6. Выводим итоговую очередь