# Задание
**Хеширование данных. Поиск данных в хеш-таблице.**

Разработать программу хеширования данных из файла методом открытого хеширования. Хеш-таблицу закодировать как класс, а операции с ней - как функции-члены класса. В программе предусмотреть следующий действия:

а) создание хеш-таблицы с небольшим количеством классов (B<=30) и небольшим набором исходных данных, вывод всей таблицы на экран, осуществление поиска по таблице, в качестве хеш-функции выбрать h(x)=x%B;

б) создание хеш-таблицы, для которой количество классов B задается пользователем (до 20000 - 50000), осуществление поиска по таблице, подсчет общего числа коллизий в таблице, нахождение самой длинной цепочки коллизий, процента заполняемости таблицы. В качестве хеш-функции выбрать h(x)=(ax+c)%B, проанализировать результаты заполняемости таблицы для различных a и c.

В качестве исходных данных выбрать - Файл действительных чисел (варианты 2,5,8,11).
# Исходный код
main.rs
```rust
#[allow(dead_code)]
mod hashmaps;

use hashmaps::proper::ProperHashMap;
use rand;
use rand::Rng;
use std::collections::hash_map::IntoValues;
use std::fs::File;
use std::io::*;

fn read_kvp_from_files(path: &str) -> Vec<(f32, String)> {
    let mut returned = vec![];
    for line in std::fs::read_to_string(path).unwrap().trim().lines() {
        let (key, value) = line.split_once(" ").unwrap();
        returned.push((key.parse::<f32>().unwrap(), value.to_owned()));
    }
    returned
}

fn main() {
    let mut random = rand::thread_rng();

    let mut basic_map = hashmaps::basic::BasicHashMap::new();

    let mut small_set =
        read_kvp_from_files("/home/chiffa/Dev/Solutions/Rust/DSA/lab9-gen/small_set.txt");
    let mut big_set =
        read_kvp_from_files("/home/chiffa/Dev/Solutions/Rust/DSA/lab9-gen/big_set.txt");

    for (key, value) in small_set {
        basic_map.insert(key, value);
    }
    println!("basic map: {basic_map}");

    let mut const_a = String::new();
    let mut const_c = String::new();
    let mut capacity = String::new();

    println!("Введите константу А");
    std::io::stdin().read_line(&mut const_a).unwrap();

    println!("Введите константу С");
    std::io::stdin().read_line(&mut const_c).unwrap();

    println!("Введите количество ячеек таблицы");
    std::io::stdin().read_line(&mut capacity).unwrap();

    let const_a = const_a.trim().parse::<usize>().unwrap();
    let const_c = const_c.trim().parse::<usize>().unwrap();
    let capacity = capacity.trim().parse::<usize>().unwrap();

    let mut map = ProperHashMap::new(const_a, const_c, capacity);

    for (key, value) in big_set {
        map.insert(key, value);
    }
    println!("{map}");

    loop {
        println!("Введите действие: 1 - поиск по значению, 2 - поиск по ключу, 3 - вывести самую длинную цепочку коллизий");
        let mut action = String::new();
        std::io::stdin().read_line(&mut action).unwrap();
        let action = action.trim();
        match action {
            "1" => {
                let mut search = String::new();
                println!("Искомое значение");
                std::io::stdin().read_line(&mut search).unwrap();
                let search_result = map.find(search.trim().to_owned());
                println!("{search_result:?}");
            }
            "2" => {
                let mut get = String::new();
                println!("Индекс");
                std::io::stdin().read_line(&mut get).unwrap();
                let idx = get.trim().parse::<f32>().unwrap();
                let index_result = map.get(idx);
                println!("{index_result:?}");
            }
            "3" => {
                println!("{:?}", map.find_longest_collision());
            }
            _ => {}
        }
    }
}
```
hashmaps/basic.rs
```rust
use core::fmt;
use std::collections::LinkedList;
#[derive(Default, Clone, Debug)]
pub struct HashNode {
    key: f32,
    value: String,
}
#[derive(Default, Clone, Debug)]
pub struct BasicHashMap {
    pub count: usize,
    pub capacity: usize,
    pub table: Box<[Option<LinkedList<HashNode>>]>,
}

impl BasicHashMap {
    pub fn new() -> Self {
        Self {
            count: 0,
            capacity: 30,
            // Make capacity limited, because otherwise what's the point?
            table: vec![None; 30].into_boxed_slice(),
        }
    }
    fn hasher(&self, value: f32) -> usize {
        (value % self.capacity as f32) as usize
    }
    pub fn insert(&mut self, key: f32, value: String) {
        let hashed_key = self.hasher(key);
        let node = self.table.get_mut(hashed_key).unwrap();
        self.count += 1;
        match node {
            Some(list) => {
                // println!("Collided: Node: {}({}) {}", key, hashed_key, value.clone());
                list.push_front(HashNode { key, value })
            }
            None => {
                let mut tmp = LinkedList::new();
                // println!("No collision! {key}, {}", value.clone());
                tmp.push_front(HashNode { key, value });
                *node = Some(tmp)
            }
        }
    }
    pub fn get(&mut self, key: f32) -> Option<HashNode> {
        let hashed_key = self.hasher(key);
        let cell = self.table.get(hashed_key).unwrap();
        match cell {
            None => None,
            Some(list) => list.iter().find(|x| x.key == key).cloned(),
        }
    }
    pub fn find(&mut self, value: String) -> Option<HashNode> {
        for cell in self.table.iter().flatten() {
            for node in cell {
                if node.value == value {
                    return Some(node.to_owned());
                }
            }
        }
        None
    }
}

impl fmt::Display for BasicHashMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Table with capacity {} and {} items,\n{:?}",
            self.capacity, self.count, self.table
        )
    }
}
```
hashmaps/proper.rs
```rust
use core::fmt;
use std::collections::LinkedList;
#[derive(Default, Clone, Debug)]
pub struct HashNode {
    key: f32,
    value: String,
}
#[derive(Default, Clone, Debug)]
pub struct ProperHashMap {
    pub count: usize,
    pub capacity: usize,
    pub collisions: usize,
    pub const_a: usize,
    pub const_c: usize,
    pub table: Box<[Option<LinkedList<HashNode>>]>,
}

impl ProperHashMap {
    pub fn new(const_a: usize, const_c: usize, capacity: usize) -> Self {
        Self {
            count: 0,
            capacity,
            // Make capacity limited, because otherwise what's the point?
            collisions: 0,
            const_a,
            const_c,
            table: vec![None; capacity].into_boxed_slice(),
        }
    }
    fn hasher(&self, value: f32) -> usize {
        (((self.const_a as f32 * value) + self.const_c as f32) % self.capacity as f32) as usize
        // ((self.const_a * value as usize) + self.const_c) % self.capacity
    }
    pub fn insert(&mut self, key: f32, value: String) {
        let hashed_key = self.hasher(key);
        let node = self.table.get_mut(hashed_key).unwrap();
        self.count += 1;
        match node {
            Some(list) => {
                self.collisions += 1;
                // println!("Collided: Node: {}({}) {}", key, hashed_key, value.clone());
                list.push_front(HashNode { key, value })
            }
            None => {
                let mut tmp = LinkedList::new();
                // println!("No collision! {key}, {}", value.clone());
                tmp.push_front(HashNode { key, value });
                *node = Some(tmp)
            }
        }
    }
    pub fn get(&mut self, key: f32) -> Option<HashNode> {
        let hashed_key = self.hasher(key);
        let cell = self.table.get(hashed_key).unwrap();
        match cell {
            None => None,
            Some(list) => list.iter().find(|x| x.key == key).cloned(),
        }
    }
    pub fn find(&mut self, value: String) -> Option<HashNode> {
        for cell in self.table.iter().flatten() {
            for node in cell {
                if node.value == value {
                    return Some(node.to_owned());
                }
            }
        }
        None
    }
    pub fn find_longest_collision(&self) -> Option<LinkedList<HashNode>> {
        let mut max_collision = LinkedList::new();
        for cell in self.table.iter() {
            for node in cell {
                max_collision = if node.len() > max_collision.len() {
                    node.clone()
                } else {
                    max_collision
                }
            }
        }
        Some(max_collision)
    }
    pub fn get_load_factor(&self) -> f64 {
        (self.table.iter().filter(|x| x.is_some()).count() as f64) / (self.capacity as f64)
    }
}

impl fmt::Display for ProperHashMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Better table with capacity {} and {} items (collisions: {}), load factor: {},\nConst A: {}, const C: {}", self.capacity, self.count, self.collisions, self.get_load_factor(), self.const_a, self.const_c)
    }
}
```
# Алгоритмы
## Поиск по значению
1. Перебираются все ячейки ProperHashMap.table (массива связанных списков)
2. Для каждой ячейки перебирается соответствующий связанный список
3. Если искомое значение найдено, возвращаем соответствующую HashNode, иначе продолжаем "ходить" по спискам и ячейкам
4. Если искомое значение не найдено, возвращаем None
## Поиск по ключу
1. К ключу применяется формула хеширования для получения индекса
2. Перебирается список в ячейке ProperHashMap.table, соответствующей индексу из пункта 1
3. Если искомое значение найдено, возвращаем соответствующую HashNode, иначе None
# Тесты
## Вывод простой хэш-таблицы
![[Pasted image 20240604111421.png]]
### Отформатированный вывод (по меньшему набору чисел)
```
[
    None,
    None,
    None,
    None,
    Some(
        [
            HashNode {
                key: 4.7947164,
                value: "NUnL8bHpMs",
            },
            HashNode {
                key: 94.6175,
                value: "Z4sbJyqAWk",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 5.6090603,
                value: "0Sn616GaYI",
            },
            HashNode {
                key: 95.63186,
                value: "yi7TARTL9r",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 6.231094,
                value: "7BIpkcslXC",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 7.041981,
                value: "gPlUlUiqXV",
            },
        ],
    ),
    None,
    Some(
        [
            HashNode {
                key: 9.343522,
                value: "Te6uW3CszO",
            },
            HashNode {
                key: 69.84918,
                value: "VAHDZTqxXp",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 40.063995,
                value: "2tp3ucHLLP",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 71.9907,
                value: "VWSF9DHQ1v",
            },
        ],
    ),
    None,
    Some(
        [
            HashNode {
                key: 103.75403,
                value: "pkgtCtRJ2b",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 74.40016,
                value: "Vs3hvWEs7N",
            },
        ],
    ),
    None,
    Some(
        [
            HashNode {
                key: 76.12752,
                value: "QbjoMPGCRb",
            },
            HashNode {
                key: 16.691357,
                value: "KQoYcx7ZHb",
            },
        ],
    ),
    None,
    Some(
        [
            HashNode {
                key: 18.035645,
                value: "h1fdbMOCy8",
            },
            HashNode {
                key: 108.15484,
                value: "G9PqJ5gc5s",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 79.94288,
                value: "l2g64EZ8n2",
            },
            HashNode {
                key: 79.24659,
                value: "x5QPnrzKit",
            },
            HashNode {
                key: 49.399227,
                value: "YPvWDJBXRe",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 20.291111,
                value: "6Vg2ZJTODI",
            },
            HashNode {
                key: 80.656784,
                value: "jPqgELfYwj",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 21.165892,
                value: "rXZfsZ4By3",
            },
        ],
    ),
    None,
    None,
    Some(
        [
            HashNode {
                key: 114.47836,
                value: "Cq7IKIfhf9",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 25.285742,
                value: "gA314t7vwU",
            },
            HashNode {
                key: 85.55757,
                value: "mN6W4HvVi6",
            },
            HashNode {
                key: 85.24919,
                value: "OAPUxyO2DF",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 56.59478,
                value: "b2P2wOdwL8",
            },
            HashNode {
                key: 116.23646,
                value: "L0g47hBbCu",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 27.817705,
                value: "r1waZGAoDH",
            },
        ],
    ),
    Some(
        [
            HashNode {
                key: 118.34365,
                value: "ZVgThUcZbQ",
            },
        ],
    ),
    None,
]
```
## Вывод данных о "нормальной" хэш-таблице
![[Pasted image 20240604111601.png]]
## Разные уровни загруженности при разных константах
![[Pasted image 20240604111845.png]]
![[Pasted image 20240604111935.png]]
![[Pasted image 20240604112046.png]]
![[Pasted image 20240604113022.png]]
![[Pasted image 20240604112132.png]]
# Влияние констант
Константа A всегда имеет влияние на загруженность таблицы и частоту коллизий, константа C же влияет на эти данные только при достаточно большом количестве общих делителей между A и количеством ячеек в таблице
Меньше всего коллизий происходит, если все числа (А, С и количество ячеек) являются взаимно-простыми