# –ó–∞–¥–∞–Ω–∏–µ
–ù–∞–ø–∏—Å–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É, —Å–∂–∏–º–∞—é—â—É—é –¥–∞–Ω–Ω—ã–µ –∏–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ —Ñ–∞–π–ª–∞ –ø–æ –∞–ª–≥–æ—Ä–∏—Ç–º—É –•–∞—Ñ—Ñ–º–∞–Ω–∞.

  

–ü—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–∂–Ω–∞ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –¥–µ–π—Å—Ç–≤–∏—è:

  

–°–∂–∞—Ç–∏–µ –¥–∞–Ω–Ω—ã—Ö

1. –û—Ç–∫—Ä—ã–≤–∞—Ç—å —Ñ–∞–π–ª, –ø–æ–¥–ª–µ–∂–∞—â–∏–π —Å–∂–∞—Ç–∏—é, –∫–∞–∫ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª –±–∞–π—Ç–æ–≤.
    
2. –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞—Ç—å —á–∞—Å—Ç–æ—Ç—É –≤—Ö–æ–∂–¥–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞ –≤ —Ñ–∞–π–ª–µ.
    
3. –ü–æ –∏–º–µ—é—â–∏–º—Å—è —á–∞—Å—Ç–æ—Ç–∞–º —Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞.
    
4. –°–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤.
    
5. –ó–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤ —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤ –∑–∞–≥–æ–ª–æ–≤–æ–∫ ‚Äì –±–∞–π—Ç—ã —Å —á–∞—Å—Ç–æ—Ç–∞–º–∏ –∏—Ö –≤—Ö–æ–∂–¥–µ–Ω–∏—è.
    
6. –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å—á–∏—Ç—ã–≤–∞—Ç—å –±–∞–π—Ç—ã –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞, –∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –∏ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤ —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤.
    

  

–†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö

1. –û—Ç–∫—Ä—ã–≤–∞—Ç—å —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤.
    
2. –°—á–∏—Ç—ã–≤–∞—Ç—å –∏–∑ —Ñ–∞–π–ª–∞-–∞—Ä—Ö–∏–≤–∞ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ —Å—Ç—Ä–æ–∏—Ç—å –ø–æ –Ω–µ–º—É –¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞.
    
3. –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å—á–∏—Ç—ã–≤–∞—Ç—å –±–∞–π—Ç—ã —Ñ–∞–π–ª–∞-–∞—Ä—Ö–∏–≤–∞, –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–∞–π—Ç—ã –ø–æ–±–∏—Ç–Ω–æ —Å –ø–æ–º–æ—â—å—é –¥–µ—Ä–µ–≤–∞ –•–∞—Ñ—Ñ–º–∞–Ω–∞ –∏ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –≤ –¥–µ—Ä–µ–≤–µ –±–∞–π—Ç—ã –≤ –Ω–æ–≤—ã–π —Ñ–∞–π–ª.
# –ö–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã
main.rs
```rust
#![feature(iter_array_chunks)]

use crate::compression::compress::compress;
use crate::compression::decompress::decompress;
use std::fs::File;

mod compression;

fn main() {
    println!("Choose your action:\n1 - compress, 2 - decompress");
    loop {
        let mut action: String = String::new();
        std::io::stdin().read_line(&mut action).unwrap();
        let act = action.trim().parse::<usize>().unwrap();

        let mut file =
            File::open("/home/chiffa/Dev/Solutions/Rust/DSA/pisha-lab3-rewrite/files/base")
                .unwrap();
        match act {
            1 => {
                compress(&mut file);
                println!("File compressed");
            }
            2 => {
                decompress();
                println!("File decompressed");
            }
            _ => println!("Try again"),
        }
    }
}

```

compress.rs
```rust

use std::collections::{BTreeMap, HashMap};
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Read, Seek, SeekFrom, Write};
use std::str::from_utf8;
use crate::compression::structs::*;
use crate::compression::consts::*;
pub fn compress(file: &mut File) -> () {
    let freq = create_frequency_map(file);
    let mut tree = freq.unwrap();
    let node = build_huffman_tree(&mut tree);
    let code = build_huffman_code(node);
    write_codes(code, tree, file)
}

fn write_codes(codes: HashMap<char, String>, frequency: BTreeMap<char, i32>, input_file: &mut File) -> () {
    let mut output_file = File::create(COMPRESSED_PATH).unwrap();
    let mut output_writer = BufWriter::new(&mut output_file);
    let mut input_reader = BufReader::new(input_file);

    let ref_reader = &mut input_reader;
    let ref_writer = &mut output_writer;

    // Write as base-10
    for (byte, freq) in &frequency {
        let byte = *byte as char;
        #[cfg(debug_assertions)]
        {
            println!("Wrote pair: {byte}{freq}");
        }
        write!(ref_writer, "{byte}{freq};").expect("write successful");
    }
    #[cfg(debug_assertions)]
    {
        println!("Wrote char count: {}", &frequency.values().sum::<i32>());
    }
    write!(ref_writer, "{}", frequency.values().sum::<i32>()).expect("separator written successfully");
    #[cfg(debug_assertions)]
    {
        println!("Wrote separator");
    }
    write!(ref_writer, "\n").expect("separator written successfully");
    let mut code_string: String = String::new();
    // Create a string to fill with codes
    let mut codes_part = String::new();

    #[cfg(debug_assertions)]
    {
        println!("Entered loop");
    }
    loop {
        let buffer = ref_reader.fill_buf().unwrap();
        let size = buffer.len();

        #[cfg(debug_assertions)]
        {
            println!("Buffer: {buffer:?}");
        }

        if size == 0 {
            break;
        }

        for byte in buffer {
            let curr_char = *byte as char;
            let code = codes.get(&curr_char).expect("File changed during the process?");
            #[cfg(debug_assertions)]
            {
                println!("char {} got code {}", curr_char, code);
            }
            code_string.push_str(code);
        }
        ref_reader.consume(size);
    }
    let mut chunks = code_string.bytes().array_chunks::<8>();
    while let Some(chunk) = chunks.next() {
        let encoded = from_utf8(&chunk).unwrap();
        let encoded = u8::from_str_radix(encoded, 2).unwrap();
        #[cfg(debug_assertions)]
        {
            println!("code {chunk:?} got encoded as {:?}", encoded as char);
        }
        ref_writer.write(&[encoded]).expect("Chunk write failed");
    }

    let mut rem: Vec<u8> = chunks.into_remainder().unwrap().clone().collect();
    let pad = 8 - rem.len();
    for i in 0..pad {
        rem.push('0' as u8);
    }
    let encoded = from_utf8(&rem).unwrap();
    let encoded = u8::from_str_radix(encoded, 2).unwrap();
    #[cfg(debug_assertions)]
    {
        println!("code remainder {rem:?} got encoded as {:?}", encoded as char);
    }
    ref_writer.write(&[encoded]).expect("Chunk write failed");

    output_writer.flush().expect("flush successful");
}

fn create_frequency_map(file: &mut File) -> Result<BTreeMap<char, i32>, String> {
    let mut map: BTreeMap<char, i32> = BTreeMap::new();

    let mut reader = BufReader::new(file);
    let ref_reader = &mut reader;

    loop {
        let buffer = ref_reader.fill_buf().unwrap();
        let buffer_length = buffer.len();
        if buffer_length == 0 {
            break;
        }
        for byte in buffer {
            map.entry(*byte as char).and_modify(|value| *value += 1).or_insert(1);
        }
        ref_reader.consume(buffer_length);
    }
    ref_reader.seek(SeekFrom::Start(0)).expect("TODO: panic message");
    Ok(map)
}
```
decompress.rs
```rust
use std::collections::{BTreeMap, HashMap};
use std::fmt::format;
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Read, Seek, SeekFrom, Write};
use std::str::from_utf8;
use crate::compression::consts::{BUFFER_SIZE, COMPRESSED_PATH, DECOMPRESSED_PATH};
use crate::compression::structs::{build_huffman_code, build_huffman_tree};

pub fn decompress() -> () {
    println!("Decompression: ");
    let mut input = File::open(COMPRESSED_PATH).unwrap();
    let (frequencies, char_count) = get_frequencies(&mut input);
    let tree = create_decompression_map(frequencies);
    println!("{tree:?}");
    // let data = parse_data(&mut input);
    write_data(&mut input, char_count, tree);

    // println!("{tree:?}");
}

fn get_frequencies(file: &mut File) -> (String, usize) {
    let mut reader = BufReader::new(file);
    let ref_reader = &mut reader;

    let mut encoding = vec![];

    ref_reader.read_until('\n' as u8, &mut encoding).unwrap();
    println!("Encoding data: {:?}", encoding.iter().map(|x| *x as char).collect::<Vec<char>>());
    ref_reader.consume(encoding.len());
    ref_reader.seek(SeekFrom::Start(0)).unwrap();
–ù–∞–ø–∏—Å–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É, —Å–∂–∏–º–∞—é—â—É—é –¥–∞–Ω–Ω—ã–µ –∏–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ —Ñ–∞–π–ª–∞ –ø–æ –∞–ª–≥–æ—Ä–∏—Ç–º—É –•–∞—Ñ—Ñ–º–∞–Ω–∞.

  

–ü—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–∂–Ω–∞ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –¥–µ–π—Å—Ç–≤–∏—è:

  

–°–∂–∞—Ç–∏–µ –¥–∞–Ω–Ω—ã—Ö

1. –û—Ç–∫—Ä—ã–≤–∞—Ç—å —Ñ–∞–π–ª, –ø–æ–¥–ª–µ–∂–∞—â–∏–π —Å–∂–∞—Ç–∏—é, –∫–∞–∫ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª –±–∞–π—Ç–æ–≤.
    
2. –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞—Ç—å —á–∞—Å—Ç–æ—Ç—É –≤—Ö–æ–∂–¥–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞ –≤ —Ñ–∞–π–ª–µ.
    
3. –ü–æ –∏–º–µ—é—â–∏–º—Å—è —á–∞—Å—Ç–æ—Ç–∞–º —Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞.
    
4. –°–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤.
    
5. –ó–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤ —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤ –∑–∞–≥–æ–ª–æ–≤–æ–∫ ‚Äì –±–∞–π—Ç—ã —Å —á–∞—Å—Ç–æ—Ç–∞–º–∏ –∏—Ö –≤—Ö–æ–∂–¥–µ–Ω–∏—è.
    
6. –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å—á–∏—Ç—ã–≤–∞—Ç—å –±–∞–π—Ç—ã –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞, –∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –∏ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤ —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤.
    

  

–†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö

1. –û—Ç–∫—Ä—ã–≤–∞—Ç—å —Ñ–∞–π–ª-–∞—Ä—Ö–∏–≤.
    
2. –°—á–∏—Ç—ã–≤–∞—Ç—å –∏–∑ —Ñ–∞–π–ª–∞-–∞—Ä—Ö–∏–≤–∞ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ —Å—Ç—Ä–æ–∏—Ç—å –ø–æ –Ω–µ–º—É –¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞.
    
3. –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å—á–∏—Ç—ã–≤–∞—Ç—å –±–∞–π—Ç—ã —Ñ–∞–π–ª–∞-–∞—Ä—Ö–∏–≤–∞, –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–∞–π—Ç—ã –ø–æ–±–∏—Ç–Ω–æ —Å –ø–æ–º–æ—â—å—é –¥–µ—Ä–µ–≤–∞ –•–∞—Ñ—Ñ–º–∞–Ω–∞ –∏ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –≤ –¥–µ—Ä–µ–≤–µ –±–∞–π—Ç—ã –≤ –Ω–æ–≤—ã–π —Ñ–∞–π–ª.
    let encoding: String = from_utf8(&encoding).unwrap().to_owned();
    let (frequencies, count) = encoding.rsplit_once(';').unwrap();
    (frequencies.to_owned(), count.trim().parse::<usize>().unwrap())
}

fn create_decompression_map(codes: String) -> HashMap<char, String> {
    let pairs = codes.split(';');
    let mut map: BTreeMap<char, i32> = BTreeMap::new();

    for pair in pairs {
        let (lhs, rhs) = pair.split_at(1);
        println!("{lhs} -> {rhs}");
        map.insert(lhs.as_bytes()[0] as char, rhs.parse::<i32>().unwrap());
    }
    build_huffman_code(build_huffman_tree(&mut map))
}

fn parse_data(file: &mut File) -> String {
    let mut reader = BufReader::new(file);
    let ref_reader = &mut reader;

    let mut res = vec![];
    let mut fake = vec![];
    ref_reader.read_until('\n' as u8, &mut fake).unwrap();

    ref_reader.read_to_end(&mut res).unwrap();

    let bytes: String = res.iter().map(|x| format!("{x:0>8b}")).reduce(|acc, l| acc + &l).unwrap();
    bytes
}

fn write_data(input: &mut File, count: usize, codes: HashMap<char, String>) {
    let mut output_file = File::create(DECOMPRESSED_PATH).unwrap();
    let mut output_writer = BufWriter::new(&mut output_file);
    let mut input_reader = BufReader::new(input);

    let ref_reader = &mut input_reader;
    let ref_writer = &mut output_writer;


    let mut fake = vec![];
    ref_reader.read_until('\n' as u8, &mut fake).unwrap();

    let mut tmp = String::new();

    loop {
        let buffer = ref_reader.fill_buf().unwrap();
        let size = buffer.len();

        if size == 0 {
            break;
        }
        for byte in buffer {
            let stringify = format!("{byte:0>8b}");
            println!("Byte to code: {byte} -> {stringify}");
            tmp.push_str(&stringify);
        }

        ref_reader.consume(size);
    }

    println!("Buffer string: {tmp}");
    for rem in (0..count).rev() {
        println!("Current state: {tmp}");
        println!("Iterations remaining: {rem}");

        for (k, v) in &codes {
            if tmp.starts_with(v) {
                println!("Matched: {v}");
                ref_writer.write(&[*k as u8]).expect("TODO: panic message");
                tmp = tmp.split_at(v.len()).1.to_owned();
                break;
            }
        }
    }
}
```
structs.rs
```rust
use std::cmp::Ordering;
use std::collections::{BTreeMap, HashMap};

#[derive(Debug, Default, Eq, PartialEq, Hash)]
pub struct Node {
    pub value: Option<char>,
    pub frequency: i32,
    pub left: Option<Box<Node>>,
    pub right: Option<Box<Node>>,
}
impl Ord for Node {
    fn cmp(&self, other: &Self) -> Ordering {
        if self.frequency == other.frequency {
            return self.value.cmp(&other.value);
        };
        self.frequency.cmp(&other.frequency)
    }
}
impl PartialOrd for Node {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

pub fn build_huffman_tree(map: &mut BTreeMap<char, i32>) -> Box<Node> {
    let mut nodes = map
        .into_iter()
        .map(|(k, v)| Some(Box::new(Node { value: Some(*k), frequency: *v, left: None, right: None })))
        .collect::<Vec<Option<Box<Node>>>>();
    nodes.sort();
    while nodes.len() != 1 {
        let left = nodes.remove(0);
        let right = nodes.remove(0);

        let mut sum_frequency = 0;
        let left = match left {
            Some(frequency) => {
                sum_frequency += frequency.frequency;
                Some(frequency)
            },
            _ => { None }
        };
        let right = match right {
            Some(frequency) => {
                sum_frequency += frequency.frequency;
                Some(frequency)
            },
            _ => { None }
        };

        let node = Node {
            left,
            right,
            value: None,
            frequency: sum_frequency,
        };
        nodes.push(Some(Box::new(node)));
        nodes.sort();
        // dbg!(&nodes);
    }
    let nodes = nodes.pop().flatten().unwrap();
    nodes
}
pub fn build_huffman_code(node: Box<Node>) -> HashMap<char, String> {
    let mut hash: HashMap<char, String> = HashMap::new();
    // let hash_ref = &mut hash;
    get_code(Some(node), "".to_string(), &mut hash);
    hash

}
fn get_code(node: Option<Box<Node>>, string: String, hash: &mut HashMap<char, String>) {
    if let Some(node) = node {
        if let Some(v) = node.value {
            hash.insert(v, string.clone());
        } else {
            get_code(node.left, string.clone() + "0", hash);
            get_code(node.right, string.clone() + "1", hash);
        }
    } else {
        return;
    }
}

#[cfg(test)]
mod test {
    use std::collections::{BTreeMap, HashMap};
    use crate::compression::structs::*;

    #[test]
    fn test_priority_sort() {
        let mut node_vec = vec![];
        node_vec.push(Some(Box::new(Node {frequency: 10, right: None, left: None, value: Some(10) })));
        node_vec.push(Some(Box::new(Node {frequency: 20, right: None, left: None, value: Some(20) })));
        node_vec.push(Some(Box::new(Node {frequency: 10, right: None, left: None, value: Some(50) })));
        node_vec.sort();
        let correct_sort = vec![
            Some(Box::new(Node {frequency: 10, right: None, left: None, value: Some(10) })),
            Some(Box::new(Node {frequency: 10, right: None, left: None, value: Some(50) })),
            Some(Box::new(Node {frequency: 20, right: None, left: None, value: Some(20) }))
        ];
        assert_eq!(node_vec, correct_sort);

    }

    #[test]
    fn test_huffman_tree() {
        let mut correct_map: BTreeMap<char, i32> = BTreeMap::new();
        correct_map.insert('A', 5);
        correct_map.insert('B', 9);
        correct_map.insert('C', 12);
        correct_map.insert('D', 13);
        correct_map.insert('E', 16);
        correct_map.insert('F', 45);
        let test_tree = build_huffman_tree(&mut correct_map);
        println!("tree: {test_tree:?}");
        assert_eq!(test_tree.frequency, 100);
        assert_eq!(test_tree.left.as_ref().unwrap().value, Some('F' as u8));
    }
    #[test]
    fn test_huffman_codes() {
        let mut correct_map: BTreeMap<u8, i32> = BTreeMap::new();
        correct_map.insert('A' as u8, 5);
        correct_map.insert('B' as u8, 9);
        correct_map.insert('C' as u8, 12);
        correct_map.insert('D' as u8, 13);
        correct_map.insert('E' as u8, 16);
        correct_map.insert('F' as u8, 45);

        let mut correct_codes: HashMap<u8, String> = HashMap::new();
        correct_codes.insert('A' as u8, "1100".to_owned());
        correct_codes.insert('C' as u8, "100".to_owned());
        correct_codes.insert('B' as u8, "1101".to_owned());
        correct_codes.insert('D' as u8, "101".to_owned());
        correct_codes.insert('E' as u8, "111".to_owned());
        correct_codes.insert('F' as u8, "0".to_owned());

        let tree = build_huffman_tree(&mut correct_map);
        let test_codes = build_huffman_code(tree);
        assert_eq!(correct_codes, test_codes);
    }
}
```
# –ê–ª–≥–æ—Ä–∏—Ç–º
## –°–∂–∞—Ç–∏–µ
1. –ò–∑ —á–∏—Ç–∞–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞ —Å–æ–∑–¥–∞—ë—Ç—Å—è –º–∞—Å—Å–∏–≤ –±–∞–π—Ç–æ–≤ –∏ –∏—Ö —á–∞—Å—Ç–æ—Ç
2. –ù–∞ –æ—Å–Ω–æ–≤–µ –º–∞—Å—Å–∏–≤–∞ —á–∞—Å—Ç–æ—Ç —Å—Ç—Ä–æ–∏—Ç—Å—è –¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞
3. –ù–∞ –æ—Å–Ω–æ–≤–µ –¥–µ—Ä–µ–≤–∞ —Å–æ–∑–¥–∞—é—Ç—Å—è –∫–æ–¥—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞
4. –í —Ñ–∞–π–ª –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –±–∞–π—Ç—ã, –∏—Ö –∫–æ–¥—ã, –∞ —Ç–∞–∫–∂–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–π—Ç–æ–≤ –≤ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–º —Ñ–∞–π–ª–µ
5. –ù–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–¥–æ–≤ –≤ –±—É—Ñ—Ñ–µ—Ä 0 –∏ 1, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞—Ç–µ–º —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è –Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ 8 –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é—Ç—Å—è –≤ –±–∞–π—Ç—ã –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ —Ñ–∞–π–ª
## –†–∞–∑–∂–∞—Ç–∏–µ 
1. –ò–∑ —Ñ–∞–π–ª–∞ —á–∏—Ç–∞–µ—Ç—Å—è –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å –±–∞–π—Ç–∞–º–∏ –∏ —á–∞—Å—Ç–æ—Ç–∞–º–∏
2. –ù–∞ –æ—Å–Ω–æ–≤–µ –±–∞–π—Ç–æ–≤ –∏ —á–∞—Å—Ç–æ—Ç –≤—ã—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –¥–µ—Ä–µ–≤–æ –∏ –∫–æ–¥—ã
3. –ò–∑ –æ—Å—Ç–∞–≤—à–µ–π—Å—è —á–∞—Å—Ç–∏ —Ñ–∞–π–ª–∞ —á–∏—Ç–∞—é—Ç—Å—è –±–∞–π—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–≤–æ–¥—è—Ç—Å—è –≤ –¥–≤–æ–∏—á–Ω—ã–π –≤–∏–¥ –∏ –¥–µ–∫–æ–¥–∏—Ä—É—é—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–µ—Ä–µ–≤–∞
4. –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–∞–π—Ç—ã –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –≤ —Ñ–∞–π–ª
# –¢–µ—Å—Ç—ã
–ò–∑–Ω–∞—á–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª
```
AAAABBBCCD
```
–°–∂–∞—Ç—ã–π —Ñ–∞–π–ª
```
A4;B3;C2;D1;10

```
–†–∞–∑–∂–∞—Ç—ã–π —Ñ–∞–π–ª
```
AAAABBBCCD
```