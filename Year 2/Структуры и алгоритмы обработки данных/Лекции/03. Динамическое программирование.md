#### Метод динамического программирования

В предыдущей задаче на больших $N$ полный перебор невозможен. 

Данную задачу можно решить более быстрым алгоритмом, реализующим метод динамического программирования. Суть метода заключается в том, что в начале решается задача минимальной размерности. Далее на основании этого решения задача следующей размерности, и так далее пока не будет решена задача требуемой размерности. При решении задачи размерности $k$ на основании уже решеной $k-1$ размерности решение принимается на основании так называемого принципа оптимальности.

##### Пример 1
Предыдущую задачу можно решить методом динамического программирования (как это делалось на ЕГЭ)

| 5   | 7   | 1   | 8   | 2   |
| --- | --- | --- | --- | --- |
| 3   | 9   | 2   | 5   | 6   |
| 7   | 6   | 1   | 2   | 7   |
| 5   | 4   | 3   | 2   | 8   |
| 9   | 9   | 6   | 1   | 2    |


| 5   | 12  | 13  | 21  | 23  |
| --- | --- | --- | --- | --- |
| 8   | 21  | 23  | 28  | 34  |
| 15  | 27  | 28  | 30  | 41  |
| 20  | 31  | 34  | 36  | 49  |
| 29  | 40  | 46  | 47  | 51  | 

Заполняя на основании исходного массива A итоговый массив B мы в ячейке `B[n-1][n-1]` (где `n` - размер измерения) получим искомое максимальное значение.
Для всех элементов массива B (кроме первой строки и первого столбца) это значение вычисляется по формуле `B[i][j] = max(B[i-1][j], B[i][j-1]) + A[i][j]`
Это и есть принцип оптимальности 
Если требуется найти не только максимальное значение суммы, но и путь, по которому эта сумма была получена, это можно сделать двигаясь от `B[n-1][n-1]` к `B[0][0]` по "жадному" алгоритму

| 1   | 1   | 1   | 1   | 1   |
| --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 5   |
| 1   | 3   | 6   | 10  | 15  |
| 1   | 4   | 10  | 20  | 35  |
| 1   | 5   | 15  | 35  | 70  |
Получается треугольник Паскаля 
$\sum\limits^{n}_{k=0}(n/k)a^{k}b^{n-k}$
формула количества путей

##### Пример 2
Некто хочет подписать бумагу у министра
Министр подписывает документ, если на нём стоит подпись любого работника с последнего этажа министерства. Каждый работник сидит в отдельном кабинете, количество кабинетов на этаже $M \in {[0,500]}$. Количество этажей $N \in{[1,100]}$. Каждый работник сидит в отдельном кабинете и подписывает документ, если на нём стоит подпись любого работника из кабинета ниже или из одного из соседних. За свою подпись каждый работник берёт некоторую взятку. Известность суммы взяток в каждом кабинете министерства. Требуется найти путь от первого этажа к последнему, чтобы конечная сумма взяток была минимальной.
###### Решение
Заведём три 2D массива. В первом хранятся исходные данные суммы взяток в каждом кабинете, во втором будем просчитывать наилучшую взятку для каждого кабинета, в третьем будем отмечать путь (откуда пришли)

A

| 10  | 10  | 1   | 10  |
| --- | --- | --- | --- |
| 10  | 10  | 1   | 10  |
| 1   | 1   | 1   | 10  |
| 1   | 10  | 10  | 10  | 

B

| 22  | 23  | 6   | 25  |
| --- | --- | --- | --- |
| 12  | 13  | 5   | 15  |
| 2   | 3   | 4   | 14  |
| 1   | 10  | 10  | 10  |

C

| 0   | 0   | 0   | 0   |
| --- | --- | --- | --- |
| 0   | 0   | 0   | -1  |
| 0   | -1  | -1  | -1  |
| 0   | 0   | 0   | 0   | 

После заполнения B и C в последней заполненной строке находим минимум, это будет итоговым значением взятки.
Путь по министерству найдём пользуясь массивом C