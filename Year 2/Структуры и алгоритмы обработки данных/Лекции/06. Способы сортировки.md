Сортировка - перемещение элементов последовательности в порядке возрастания (неубывания) или убывания (невозрастания)
# Области применения сортировки
1. Группировка объектов по признаку
2. Поиск общих элементов в двух или более последовательностях
3. Задача поиска
## Постановка задачи
Пусть необходимо упорядочить N записей вида $R_{1}..R_{n}$.
Пусть каждая запись $R_{i}$ имеет ключ $k_{i}$, который и управляет процессом сортировки (В дальнейшем будем сортировать только ключи). Введём в множестве ключей отношение порядка меньше, такое что для любых трёх значений ключей a,b,c выполняются два условия:
1. Существует одно и только одно утверждение: либо a < b, либо b < a, либо b == a (закон трихотомии)
2. Если a < b, b < c => a < c
Любое множество с данным отношением подлежит сортировке в выбранном нами смысле, то есть записи упорядочиваются в ряд $R_{i1},R_{i2}..R_{in}$, где $k_{i1}\le{k_{i2}}\le{...}\le{k_{in}}$ 
# Сложность алгоритма
Скорость выполнения некоторой программы во многом зависит от быстродействия компьютера. Но даже на самом быстром компьютере одни программы будут работать быстро, а другие медленно. Это связано со сложностью алгоритмов. Под сложностью понимается количество элементарных операций (шагов цикла), которые будут выполнены с исходными данными размером `n`. Например, если для решения задачи используется два вложенных цикла, и каждый цикл производит `n` итераций, а тело выполняется за время `c` (константа), то время на выполнение будет пропорционально $c*n^{2}$
При малых `n` константа `c` играет существенное значение, но чем больше `n`, тем меньше влияние `c`, поэтому при оценке сложности `c` опускается. Сложность чаще всего расчитывается для худшего случая, и это описывается с помошью Big-O notation
Среди методов сортировки массивов выделяют три базовых:
1. Прямого включения
2. Прямого выбора
3. Прямого обмена
## Метод прямого выбора
Среди всех элементов ищется минимальный и меняется местами с первым. Далее минимальный ищется среди оставшихся и меняется местами со вторым и т.д.
Сложность метода квадратичная
## Метод вставки
i-ый элемент вставляется среди предыдущих на подходящее для него место
Это делается для всех элементов от второго до последнего
Худший + средний случаи - O(n^2), лучший - O(n) (внутренний цикл не выполняется)
## Метод прямого обмена
Последний элемент массива сравнивается с предпоследним, и если последний меньше, меняются местами. Предпоследний элемент сравнивается с третьим с конца, если предпоследний меньше - меняются местами. И т.д.
В результате на первом месте окажется минимальный элемент. Процедура повторяется и движется до начала массива. Алгоритм называется bubble sort, т.к. если представить массив вертикальным, минимальный элемент "всплывает", как пузырь.
Два вложенных цикла дают сложность O(n^2)

Среди трёх базовых методов insertion sort самый быстрый, bubble sort - самый медленный
## Shaker sort
Является улучшением баббл сорта
1. Запоминать перестановки в процессе прохода (для раннего выхода)
2. Запоминать место последнего обмена, после него массив уже отсортирован
3. Проводить сортировку последовательно в двух направлениях
Сложность:
best-case - O(n)
worst-case - O(n^2)