Сортировка - перемещение элементов последовательности в порядке возрастания (неубывания) или убывания (невозрастания)
# Области применения сортировки
1. Группировка объектов по признаку
2. Поиск общих элементов в двух или более последовательностях
3. Задача поиска
## Постановка задачи
Пусть необходимо упорядочить N записей вида $R_{1}..R_{n}$.
Пусть каждая запись $R_{i}$ имеет ключ $k_{i}$, который и управляет процессом сортировки (В дальнейшем будем сортировать только ключи). Введём в множестве ключей отношение порядка меньше, такое что для любых трёх значений ключей a,b,c выполняются два условия:
1. Существует одно и только одно утверждение: либо a < b, либо b < a, либо b == a (закон трихотомии)
2. Если a < b, b < c => a < c
Любое множество с данным отношением подлежит сортировке в выбранном нами смысле, то есть записи упорядочиваются в ряд $R_{i1},R_{i2}..R_{in}$, где $k_{i1}\le{k_{i2}}\le{...}\le{k_{in}}$ 
# Сложность алгоритма
Скорость выполнения некоторой программы во многом зависит от быстродействия компьютера. Но даже на самом быстром компьютере одни программы будут работать быстро, а другие медленно. Это связано со сложностью алгоритмов. Под сложностью понимается количество элементарных операций (шагов цикла), которые будут выполнены с исходными данными размером `n`. Например, если для решения задачи используется два вложенных цикла, и каждый цикл производит `n` итераций, а тело выполняется за время `c` (константа), то время на выполнение будет пропорционально $c*n^{2}$
При малых `n` константа `c` играет существенное значение, но чем больше `n`, тем меньше влияние `c`, поэтому при оценке сложности `c` опускается. Сложность чаще всего расчитывается для худшего случая, и это описывается с помошью Big-O notation
Среди методов сортировки массивов выделяют три базовых:
1. Прямого включения
2. Прямого выбора
3. Прямого обмена
## Метод прямого выбора
Среди всех элементов ищется минимальный и меняется местами с первым. Далее минимальный ищется среди оставшихся и меняется местами со вторым и т.д.
Сложность метода квадратичная
## Метод вставки
i-ый элемент вставляется среди предыдущих на подходящее для него место
Это делается для всех элементов от второго до последнего
Худший + средний случаи - O(n^2), лучший - O(n) (внутренний цикл не выполняется)
## Метод прямого обмена
Последний элемент массива сравнивается с предпоследним, и если последний меньше, меняются местами. Предпоследний элемент сравнивается с третьим с конца, если предпоследний меньше - меняются местами. И т.д.
В результате на первом месте окажется минимальный элемент. Процедура повторяется и движется до начала массива. Алгоритм называется bubble sort, т.к. если представить массив вертикальным, минимальный элемент "всплывает", как пузырь.
Два вложенных цикла дают сложность O(n^2)

Среди трёх базовых методов insertion sort самый быстрый, bubble sort - самый медленный
## Shaker sort
Является улучшением баббл сорта
1. Запоминать перестановки в процессе прохода (для раннего выхода)
2. Запоминать место последнего обмена, после него массив уже отсортирован
3. Проводить сортировку последовательно в двух направлениях
Сложность:
best-case - O(n)
worst-case - O(n^2)
## Shell sort
Сначала отдельно группируются и сортируются элементы, отстоящие друг от друга на расстояние `len/2`. Затем на расстоянии `n/4`, пока не дойдём до обычной одинарной сортировки. На каждом проходе сортировка программируется как сортировка вставками, поэтому если какая-то последовательность уже отсортирована, происходит переход к следующей
Сортировка даёт выигрыш по сравнению с классическими методами, потому что на каждом шаге сортируется либо немного элементов, либо элементы уже почти отсортированы.
В классической сортировке шелла расстояние между элементами меняется как кратные чётные числа. На самом деле это не лучший вариант - до сих пор окончательно неизвестно, при каких расстояниях серий скорость максимальна, но точно известно, что они не должны быть множителями друг друга
Хороший результат дают серии по типу `1, 4, 12, 40, 121...` или `1, 3, 7, 15, 31...`
При этом сложность метода при хорошем распределении $O(n^{\frac{1}{2}})$ 
## Пирамидальная
Одномерный массив представляется как бинарное дерево. У первого потомки 1 и 2, у второго 3 и 4, etc.
Затем все узлы дерева выстраиваются в таком порядке, что никакой родитель не меньше своих потомков. В результате такой процедуры корень дерева (нулевой элемент массива)
В результате все элементы дерева "находятся на своих местах" за исключением нулевого элемента. Его нужно протолкнуть по дереву до требуемого места. После этого в корне дерева вновь окажется максимальный их оставшихся элемент. Выстраивание дерева в "хорошем" виде требует одного прохода по элементам (O(n)), в дальнейшем каждый элемент  проталкиваем по дереву, затрачивая не более $\log_{2}(n)$. Всего элементов n. Сложность - $O(n\log_{2}(n))$ 
## Quicksort
В массиве выбирается т.н. опорный элемент, стоящий в его центре. После этого все элементы массива переставляются таким образом, что слева оказываются элементы < опорного, справа - >= опорного, после этого сортировка рекурсивно применяется к левой и правой частям массива. Обмен элементами производится следующим образом - слева ищется элемент >= опорного, справа < опорного, меняются местами и т.д.
Если ключевой элемент выбирается таким образом, что элементы массива делятся им по значениям меньше/больше ровно пополам,то левая и правая части относительно ключа будут одинаковы, и количество таких делений будет логарифмом, при этом на каждом проходе пробегаем по всем элементам, сложность $O(nlog(n))$
1
## Pocketsort
Единственная сортировка со сложностью $O(n)$, но для этого множество значений ключа должно быть ограничено и ограничение должно быть известно.
Заводится несколько карманов, где каждый элемент - указатель на список, в котором 