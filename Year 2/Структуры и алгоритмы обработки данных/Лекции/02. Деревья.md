Дерево - совокупность элементов, называемых узлами, один из которых определяется как корень, и родительских отношений, определяющих иерархическую структуру дерева
Рекурсивное определение дерева:
1. Один узел является деревом, этот же узел является его корнем
2. Пусть `n` - узел, и $T_{1},T_{2},...,T_{k}$ - деревья с корнями $n_{1},n_{2},...,n_{k}$ соответственно. Можно построить новое дерево, сделав $n$ родителем узлов $n_k$. В этом дереве $n$ - корень, $t_{k}$ - поддеревья, а узлы $n_{1},n_{2},n_{k}$ - прямые потомки узла $n$
Путём из узла $n_{1}$ в узел $n_{k}$ является последовательность вершин $n_{2},n_{3},...,n_{k-1}$, где для всех $k\ge{i}\gt{1}$ узел $n_{i}$ является родителем для узла $n_{i+1}$
Длиной пути называется число, на единицу меньше количества узлов, составляющих этот путь
3. Если существует путь $a\;\rightarrow{}\;b$, то $a$ - предок узла $b$, $b$ - потомок узла $a$. Считается, что любой узел является предком и потомком самого себя. Таким образом, корень дерева - узел, не имеющий никаких предков, кроме самого себя
4. Узел, не имеющий других потомков, кроме самого себя, называется листом или терминальной вершиной дерева
5. Высота вершины - длина самого длинного пути от этой вершины до одного из листов дерева. Высотой дерева называется высота его корня
6. Глубина узла - длина пути от корня до узла
7. Дерево, в котором нет ни одного узла, называется нулевым
![[Пример дерева.png]]
## Способы обхода деревьев
Обход дерева фактически является упорядочиванием его вершин по некоторому правилу
Наиболее часто встречаются три вида обхода деревьев:
1. Прямой
2. Обратный
3. Симметричный
Правила обхода:
Если дерево $T$ является нулевым деревом, то в список обхода заносится нулевая запись
Если дерево $T$ состоит из одного узла, то в список обхода заносится этот узел
Пусть $T$ - дерево с корнем $n$ и поддеревьями $T_{1},T_{2},...,T_{k}$
![[Дерево.png]]
Тогда для различных способов обхода:
- При прямом обходе сначала посещается $n$, затем поддеревья $T_{1}\rightarrow{}T_{k}$ в прямом порядке
- При обратном обходе сначала в обратном порядке обходится поддерево $T_{1}$, затем $T_{2} \rightarrow{} T_{k}$, последним обходится $n$
- При симметричном обходе сначала в симметричном порядке обходится дерево $T_{1}$, затем корень $n$, далее поддеревья $T_{2}\rightarrow{}T_{k}$
![[Виды обходов.png]]
## Бинарные деревья
Отдельные интерес в теории алгоритмов вызывают деревья, у каждого узла которых не более 2 потомков. Такие деревья называются бинарными или двоичными (не путать с б-деревьями)
Бинарное дерево называется сбалансированным, если разность высот левого и правого поддеревьев у любого узла дерева равна $\in[-1;1]$ 
Если эта разность для любого узла равна нулю, дерево идеально сбалансировано
### Способы представления бинарных деревьев
#### С помощью одномерного массива
![[Одномерный-массив-дерево.png]]
Дерево разбивается по уровням, которые записываются сверху вниз, а пустые ноды заменяются на null
![[одномерный-массив.png]]
#### С помощью динамической структуры
```c++
struct Node {
	int data;
	Node *left, *right;
}

void add(int x, Node *&node) {
	if (node == NULL) {
		node = new Node;
		node->data = x;
		node->left = NULL;
		node->right = NULL;
	}
}

void printTree(Node *&node) {
	if (node != NULL) {
		// Прямой обход дерева
		cout << node->data << " ";
		printTree(node->left);
		// Симметричный обход
		// cout << node->data << " ";
		printTree(node->rigth);
		// Обратный обход
		// cout << node->data << " ";
		// Порядок обхода зависит от того, где вызывается вывод, да. Шиза
	}
}
```
### Дерево Хаффмана
Будем строить бинарное дерево Хаффмана с использованием динамических структур данных
Узел будет содержать в себе частоту (вероятность) вхождения символа, символ, а также указатели на левое поддерево, правое поддерево, родительский узел.
Помимо структуры объявим два одномерных массива размером 256 элементов. В массиве `trees` изначально будем хранить указатели на узлы с отдельными символами. По мере построения дерева будем объединять эти символы в деревья, указатели на корни также хранить в этом массиве, и так до тех пор, пока не останется одного дерева
В массиве `symbols` - указатели на каждый символ, чтобы используя их, двигаясь к родительским узлам, быстро найти код символа
В переменной `size` - реальное число символов
```c++
class HaffmanTree {
	private:
		struct Node {
			double p;
			char c;
			Node *left, *right, *parent;
		}

	Node *trees[256], *symbols[256];
	int size;
	void makeTree(int col) {
		if (col > 1) {
			double minp1 = 1;
			int n1 = 0;
			for (int i = 0; i < size; i++) {
				if (trees[i] != NULL &&
				trees[i]->p < minp1) {
					minp1 = trees[i]->p;
					n1 = i;
				}
			double minp2 = 1;
			int n2 = 0;
			for (int i = 0; i < size; i++) {
				if (trees[i] != NULL &&
				trees[i]->p < minp2 &&
				i != n1) {
					minp2 = trees[i]->p;
					n2 = i;
				}
			}
			Node *tmp = new Node;
			tmp->left = trees[n1];
			tmp->right = trees[n2];
			trees[n1]->parent = tmp;
			trees[n2]->parent = tmp;
			tmp->p = trees[n1] ->p+trees[n2]->p;
			tmp->parent = NULL;
			trees[n1] = tmp;
			trees[n2] = NULL;
			makeTree(col - 1);
		}
	}
}
```

### Алгоритмы полного перебора

Многие задачи заключаются в нахождении одного или нескольких искомых из полного набора некоторых вариантов. Эти задачи называются задачами выбора на доборе дискретных данных. Самый простой способ решения задачи выбора - перебрать все варианты и выбрать среди них те которые требуются по условию.

Плюсом данного метода является гарантированное получение точного и полного результата. Главным минусом является большая временная сложность алгоритма при большом наборе исходном данных. 

#### Перебор циклами

Программа представляет собой несколько вложенных циклов которые и перебирают все варианты. 

Пример: Найти количество счастливых автобусных билетов.

```cpp
int col=0;
for (int a=0;a<=9;a++)
	for (int b=;b<=9;b++)
		for (int c=0;c<=9;c++)
			for (int d=0;d<=9;d++)
				for (int e=0;e<=9;e++)
					for (int f=0;f<=9;f++)
		if (a+b+c==d+e+f) col++;
		cout << col << " " << col/10000.0 << endl;


```

```rust
let mut count: i32 = 0;  
for a in 0..10 {  
    for b in 0..10 {  
        for c in 0..10 {  
            for d in 0..10 {  
                for e in 0..10 {  
                    for f in 0..10 {  
                        let left: i32 = &a + &b + &c;  
                        let right: i32 = &d + &e + &f;  
                        if left == right { count += 1; }  
                    }                }            }        }    }}  
println!("{}", count);
```
Преимущество перебора циклами:
- простота реализации
Недостатки:
- часто заранее неизвестно какое количество циклов нужно вкладывать друг в друга

#### P-ичный перебор

Имеется $N$ объектов каждому их которых поставлена некоторая стоимость. Требуется разделить объекты на две группы так, чтобы разность стоимостей между группами была минимальной.

Поскольку каждый объект может оказаться в одной из двух групп закрепим за каждым из объектов двоичное число (0 или 1). Если количество объектов $N$ для полного перебора необходимо просмотреть все комбинации $n-значных$ двоичных чисел от $n-нулей$ и $n-единиц$. Всего $2^i$.

Для реализации помимо массива объектов можно завести массив нулей и единиц. Считая его двоичным числом, на каждом шаге при выборе нового варианта прибавляя к этому числу 1.

```cpp
void plus(int *m,int n){
	int i=n;
	while (m[i]==1)
		mm[i--]=0;
	m[i]=1;
	}

int main(){
	const int n=5;
	int min=15;
	int m[n+1]={0,1,2,3,4,5},
		bin[n+1]={0,0,0,0,0,0};
	while (bin[0]==0){
		int s1=0,s2=0;
		for (int i=1;i,+n;i++)
			if (bin[i]==0) {s1+=m[i];}
			else {s2+=m[i];}
			if (abs(s1-s2)<min)
				min=abs(s1-s2);
			plus(bin,n)
	}
}
```

```rust

```
Данная задача решена методом полного двоичного перебора. В общем случаи перебор может быть P-ичным.
Например: Цифры 1,2,3,4,5,6,7,8,9 записаны одна за другой. Расставить между ними знаки $+, -, *, :$ или ничего , так чтобы получилось заданное число $N$. Задачу можно решит полным пятеричным перебором.

#### Полный рекурсивный перебор

Дан квадратный числовой массив. Найти путь из левого верхнего угла массива в правый нижний, чтобы сумма чисел по данному пути была максимальной. Из каждого элемента массива допустимо двигается только вправо или вниз.

![[Полный рекурсивный перебор.png]]

```cpp
int Max=0;
void poisk(int *m,int n,int i,int j,int s){
	s+=m[i][j];
	if (i==n-1 && j==n-1 && s>Max) Max=s;
	if (i<n-1) poisk(m,n,i+1,j,s);
		if (j<n-1) poisk(m,n,i,j+1,s);
}

int main(){
	const int n=5;
	int m[n][n]={{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1}};
	int **a=new int*[n];
	for (int i=0;i<n;i++){
		a[i]=new int [n];
		for (int j=0;j<n,j++)
			a[i][j]=1;
		}
		poisk(a,n,0,0,0);
}
```

Основной плюс функций рекурсивного перебора в их простоте и компактности. Минус возможное переполнение стека и медленная работа.