Граф - любое конечное множество точек (вершин), некоторые из которых соединены дугами, можно рассматривать как граф.  
Обычно под вершинами понимаются некоторые объекты (населённые пункты, люди, государства), под дугами - отношения между ними (дороги, границы).   
Две вершины могут быть соединены дугами, идущими в одном направлении. Такие дуги называются кратными, а граф, содержащий кратные дуги - мультиграфом. В дальнейшем без особого указания будем рассматривать простые графы  

# Определения
Простым ориентированным графом называется пара объектов $G=(V,E)$, где $V$ - конечное множество, $E$ - конечное подмножество декартова произведения $VxV$  
$AxB=\{(a_{i},b_{i}), a_{i}\in{A},b_{i}\in{B}\}$
$V$ - множество вершин, $E$ - множество дуг
![](Пример%20графа.png)  
Дуга представлена в виде упорядоченной пары вершин $AB$, где $A$ - начало, $B$ - конец дуги, и говорят, что дуга $AB$ ведёт $A\to{B}$, $B$ - смежная с $A$  
Граф $G=(V,E)$ называется симметрическим, если для любых $i,j;(v_{i},v_{j}\in{E})$ 
Часто в симметрических графах дуги $(v_{i},v_{j});(v_{j},v_{i})$ заменяют рёбрами, а граф неориентированным графом.  
В графе $G$ дугу $u\in{E}$ и $v\in{V}$ называют инцидентными, если, если дуга входит или выходит из вершины.  
Путём в $G$ называется последовательность $A,B,C,...,V_{n}$, для которых существуют дуги $(A,B),(B,C)...$  
Длина пути - количество дуг, составляющих этот путь. Иногда каждой дуге присваивается некоторая стоимость (вес дуги). В этом случае длина пути является суммой весов.  
Путь называется простым, если все вершины в нём (за исключением потенциально первой и последней) различны
Цикл - простой путь в графе длиной не менее 1, у которого начальная и конечная вершины совпадают.  
Граф $G$ называется сильносвязным, если для любых двух вершин $v_{i},v_{j}\in{V}$ существует путь из $v_{i}$ в $v_{j}$, но $v_{i}\ne{v_{j}}$.  
Подграф $G'$ называется компонентой связности графа $G$, если:  
1. $G'$ связен  
2. $G'$ обладает свойством максимальности (не существует вершины, не принадлежащей $G'$, при добавлении которой $G'$ остался бы связен)  
# Способы представления графов
## Матрица смежности
Матрицей смежности для $G=(V,E)$ где $V=\{1..n\}$ - матрица $A$ размером $n*n$, где $A_{ij}=1$ тогда и только тогда, когда существует дуга $(ij)$. Все остальные элементы матрицы равны нулю

| 0   | 1   | 0   | 0   |
| --- | --- | --- | --- |
| 1   | 0   | 1   | 0   |
| 0   | 0   | 0   | 1   |
| 0   | 0   | 0   | 0   | 
## Списки смежности
Списки смежности - одномерный массив указателей размером $n$. $i$-ый элемент массива указывает на список всех вершин, смежных с $i$-ой
![](Список%20смежности.png)
Занимает меньше памяти, обход короче при малом количестве вершин и дуг
# Задача о киненгсбергских мостах
![](Pasted%20image%2020231020131700.png)
Город Кёнингсберг располагается на двух берегах реки и двух её островах. Берега и острова соединены мостами.  
Вопрос - можно ли выйти из дома, пройти по каждому мосту ровно один раз и снова вернуться домой
# Обход графа в ширину
Лабиринт состоит из множества комнат одинакового размера. Некоторые из комнат соединены дверями. Определить, можно ли пройти из комнаты А в комнату Б, и если да, за какое минимальное количество переходов.   
Математической моделью данной задачи является неориентированный граф
Проще всего задача решается обходом графа в ширину, начиная с вершины А
## Алгоритм
1. Присваиваем вершине А метку 0
2. Всем вершинам смежным с А присваиваем метку 1
3. Процесс продолжается следующим образом - всем непомеченным вершинам, смежным с единицами, присваивается метка 2
4. Если помечена вершина Б, алгоритм завершается, метка вершины Б - расстояние
5. Если на некотором шаге ни одна вершина не получила новую метку, а вершина Б не помечена, пути А -> Б не существует
Если необходимо найти путь, из Б ищем метку на 1 меньше, чем метка Б, и так до А
```cpp
public int makeWave(int a, int b) {
	int path[] = new int[size + 1];
	for (int i = 1; i <= size; i++) {
		path[i] = -1;
	}
	path[a] = 0;
	int num = 1;
	int i = 1;
	bool f = false;
	bool f1 = true;
	do {
		while (i <= size && path[i] != num - 1) {
			i++;
		}
		if (i <= size) {
			f = true;
			for (int j = 1; j <= size; j++) {
				if (gr[i][j] == 1 && path[i] == -1) {
					path[k] = num;
				}
			i++;
		} else {
			if (f) {
				i = 1;
				f = false;
				num++;
			} else {
				f1 = false;
			}
		}
	} while (f1);
	return path[b];
	}
}
```
Обход в ширину фактически позволяет найти путь минимальной длины от А до любой другой вершины в произвольном невзвешенном графе. Если рёбра графа имеют стоимость, обход в ширину задачу не решает. Если есть веса, работает алгоритм Дейкстры
## Алгоритм Дейкстры
Если имеется произвольный взвешенный граф с неотрицательными весами. Требуется найти путь минимальной стоимости из А в Б
![](Pasted%20image%2020240206161401.png)
1. Присвоим вершине А метку 0, объявив метку постоянной, остальным вершинам присвоим метку $+\infty$, считая их временными
![](Pasted%20image%2020240206161506.png)
2. Берём вершину, получившую постоянную метку на шаге 1, и для каждой смежной с ней вершиной пересчитываем метку по формуле $tag[j]=min(tag[j], tag[i] + graph[i][j])$
3. Из всех временных меток выбираем минимальную, делаем её постоянной, если она не искомая, идём на пункт 2, иначе 4
4. Постоянная метка вершины Б и есть минимальная стоимость искомого пути. Сам путь можно найти двумя способами - либо считать путь от Б к А, либо заранее записывать метки
# Алгоритм Флойда
$A_{k}[i][j]=min(A_{k-1}[i][j], A_{k-1}[i][k]+A_{k-1}[k][j])$
Данный алгоритм использует матрицу $A$ размером $n\cdot{}n$, в которой находятся длины кратчайших путей между всеми парами вершин. В начале матрица $A$ совпадает с матрицей стоимости, но если дуга $i-j$ отсутствует, то $A[i][j]=-\infty$, все $A[i][i]=0$
Над матрицей $A$ выполняется $n$ итераций. После $k$-ой итерации $A[i][j]$ содержит стоимость кратчайшего пути из $i$ в $j$, то дуга стоимости $A[i][j]$, который не проходит через вершины с номерами больше чем $k$
В лучшем случае это запишется формулой выше
```cpp
for (int k = 1; k <= size; k++) {
	for (int i = 1; i <= size; i++) {
		for (int j = 1; j <= size; j++) {
			if (a[i][k] + a[k][j] < a[i][j]) {
				a[i][j] = a[i][k] + a[k][j];
			}
		}
	}
}
```
## Транзитивное замыкание
$A_{k}[i][j]=A_{k-1}[i][j]\;or\;(A_{k-1}[i][k]\;and\;A_{k-1}[k][j])$
В ряде случаев интерес представляетлишь факт того, существует ли путь $i\rightarrow{}j$ или нет.
Задачу можно решить алгоритмом Флойда, однако несколько раньше она была решена Уоршаллом: Требуется преобразовать матрицу смежности таким образом, что $A[i][j]$ равно единице тогда и только тогда, когда существует путь $i\rightarrow{}j$, все остальные элементы равны нулю. Такая матрица называется транзитивным замыканием графа $J$, и если считать 0 = false, 1 = true
# Обход графа в глубину
Пусть имеется граф $J$, в котором первоначально все вершины помечены как `unvisited`
Обход в глубину начинается с выбора начальной вершины $V_{0}$, которая помечается `visited`. Затем для каждой смежной с ней вершины, помеченной `unvisited` рекурсивно повторяется обход в глубину
Когда все вершины, которые можно посетить из $V_{0}$, будут помечены, обход завершается. Если при этом в графе остались вершины, ещё не посещенные, можно выбрать одну из них и повторить обход, продолжая так до тех пор, пока все вершины не будут помечены