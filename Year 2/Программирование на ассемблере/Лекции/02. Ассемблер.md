Машинный язык - комбинация строгоорганизованных последовательностей нулей и единиц. Компьютер понимает только свой машинный язык.  
В 1950-ые программисты стали использовать символический аналог машинного языка, который назвали языком ассемблера. Этот язык точно отражает особенности машинного языка, поэтому для каждого типа компьютеров он свой.  
Алфавит ассемблера:  
\[a-zA-Z\]\[0-9\]\[\_?@$&,.\[\]()<>+/\*%!"\\=#^\]
Идентификатор - последовательность допустимых символов для обозначения имён переменных и меток. Длина может составлять 256 символов, а транслятор воспринимает первые 32. Идентификатор не может начинаться с цифры. Точка может быть только первым символом.  
Ключевые слова - служебные символы ASM, к которым относятся названия регистров и операторы. Целые числа могут записываться в двоичной, восьмеричной, десятичной, шестнадцатиричной системах  счисления.  
Символы и строки заключаются в одинарные или двойные кавычки, в качестве символов можно использовать русские буквы. В строках прописные и строчные символы не эквивалентны.  
Программа на языке ASM - последовательность предложений, каждое из которых записывается в отдельной строке. Переносить предложение на другую строку нельзя. По смыслу все предложения делятся на 3 группы:  
1. Комментарии  
2. Команды  
3. Директивы  
### Комментарии
Комментарием считается любая строка, начинающаяся со знака `;`, либо пустая строка. Также допустим многострочный комментарий, который начинается со слова `COMMENT <marker><text>`, где `COMMENT` - директива ассемблеру, `<marker>` - любой символ, отличный от пробела. Концом комментария считается конец строки, в которой снова в любой позиции встретился этот же маркер.  
Многострочный комментарий обычно используется для временного исключения фрагментов программы
```nasm
; this is a comment
this is a comment
COMMENT *this is a 
multiline comment*
```
### Команды
Команда - символьная форма записи машинных команд в форме `<tag>:<mnemocode><operands>;<comment>`  
Мнемокод - служебное слово, указывающее в символьной форме операцию, которую должна выполнить команда
```nasm
LAB:addl SI,3 ; address change
```
### Директивы
Директива - приказ ассемблеру со следующим синтаксисом
`<name><directive name><operand>;<comments>`
#### Директивы определения данных
Директивы определения данных размером в байт, слово, двойное слово
`<name> DB <operand>`  
Встречая такие директивы, ассемблер вычисляет операнды и записывает их значения в последовательные байты `памяти`. Первому из этих байтов даётся указанное имя, по которому на этот байт можно ссылаться из других мест программы. Существует два способа задания операндов.  

Для переменной x отводится один байт памяти, в который ничего не записывается. Выделив байт под переменную ассемблер запоминает его адрес. Когда в тексте программы встретится данное имя, ассемблер заменит его на адрес, который принято называть значением имени X.  
Размер переменной в памяти называется типом переменной, тогда значение и тип имени переменной однозначно определяют ячейку, обозначаемую этим именем.  
В ассемблере есть оператор типа. Значением этого оператора является размер ячейки, выделенной под переменную в байтах
```nasm
x DB ?
type x; = byte = 1
```
Константное выражение от -128 до 255
```nasm
a DB 254
b DB 17h
```
При описании переменной-массива имя даётся его первому элементу, остальные остаются безымянными
```nasm
M DB 2,-2,?,'*'; M = 02 FE ? 2A
type M; = 1, it only shows the size of the name
```
Для ссылок на байты массива используют ссылки вида `M+k`, где `k`  - целое число
```nasm
M + 1; address of FE
M + 3; address of '*' (2A)
```
Если несколько соседних операнд - символы, их можно объединить в строку
```nasm
S DB 'a'
DB 'b'
DB 'c'
; S = 'abc' = 61 62 63
; equal to S DB 'abc'
; TYPE S = 1
```
Если необходимо описать байтовый массив, состоящий из нескольких байтовых элементов, можно использовать `DUP()`
```nasm
R DB 8 DUP(0); = R DB 0,0,0,0,0,0,0,0
; 8 - repetition coefficient
; DUP - keyword, 0 - repeated symbol
G DB 10 DUP (20 DUP(?)); 2D array
```

```nasm
DW; initialize one word in memory
DD; initialize one double word in memory
```
Для DW операндой может быть адрес
```nasm
C DB ?
D DW C
```
Ассемблер записывает в слово `D` адрес `C`, который становится начальным значением `D`  
Для DD диапазон значений:  
1. $-2^{31}\to 2^{32}-1$
2. Константные выражения $-2^{15}\to 2^{16}-1$, т.к. все выражения вычисляются в области 16-битовых чисел
```nasm
A DD ?
B DD 123456h
C DD 33 DUP(?)
```

```nasm
C DB ?
D DD C
```
Ассемблер заменяет имя переменной `C` на адресную пару, состоящую из сегмента и смещения имени внутри сегмента
#### Директива эквивалентности
Если в правой части директивы указано имя регистра, переменной или константы, тогда имя слева объявляется синонимом данного имени, и все последующие вхождения этого имени-синонима ассемблер будет заменять на имя справа   
```nasm
A EQU B; A = B
A DW ?
B EQU A
C DW B; equal to C DW A
```
Константы:
Все последующие вхождения в текст программы имени константы заменяются на значение константы
```nasm
N EQU 100
K EQI 2*N-1
```
#### Директива присваивания
Определяет константу с именем, указанным слева и значением, указанным справа. Может менять значение
```nasm
K = 10
A DW K; A = 10
K = K + 4
B DB K; B = 14
```

```nasm
K = 1
N EQU K
A DW N
K = 2
B DB N
; N = 1
; A = 1
; B = 2
```

```NASM
K = 1
N EQU K+10
C DW N
K = 2
D DW N
; N = 11
; C = 11
; D = 11
```
Выражения ассемблера вычисляются во время трансляции
Встроив в текст программы выражение, ассемблер вычисляе его и полученное значение записывает в программу, поэтому compile-time calculation невозможны 
Приоритет операторов
1. () [] LENGTH SIZE WIDTH MASK
2. .
3. :
4. PTR OFFSER SEG TYPE THIS
5. HIGH LOW
6. (unary) + -
7. * / MOD SHL SHR
8. (binary) + -
9. EQ NE LT LE GT GE
10. NOT
11. AND
12. OR XOR
13. SHORT TYPE

# Сдвиги
После занесения знакового <украсть у кого-то>
