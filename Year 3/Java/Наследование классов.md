```java
class Foo {

}
class Bar extends Foo {

}
```
Наследование классов строго одиночное, наследование интерфейсов может быть множественным
При наследовании, конструктор `Bar` должен вызвать конструктор `Foo` как `super(this)`
апкастинг автоматический
Полиморфизм
overloading
overriding
# Полиморфизм
`final` используется для описания полей/методов, которые нельзя `override`-ить, и классов, от которых нельзя наследовать
`final Method()` не может быть переопределён
`final class Foo` не может наследоваться
# Абстрактные классы
```java
public abstract class Foo {
	int Bar(int s) {}
	public abstract int Baz();
}
```
# Интерфейсы
Интерфейс изначально был задуман как полностью абстрактный класс без полей, кроме static final. Говорят, что один класс наследует другой, но реализует интерфейс. Поскольку интерфейс полностью абстрактен, для интерфейсов допустимо множественное наследование
```java
public interface IFoo {
	int FooFun(String param);
}

public interface IBar {
	int BarFun(int param);
}

public class Baz implements IFoo, IBar {
	public int FooFun(String param) { ... }
	public int BarFun(int param) { ... }
}
```
# Вложенные классы
Класс может быть вложен в другой класс или метод другого класса
```java
public class Foo {
	int x;
	Outer(int x) {
		x = x;
	}
	class Inner {
		int Bar(String s);
	}
}
```
При компиляции, Java сформирует два файла - файлы для классов Outer, Inner. Для вложенных классов вида Inner имеет смысл спецификаторы `protected`, `private`. Внутри класса Outer объекты класса Inner создаются обычным образом. Вне Outer для создания объекта Inner нужен существующий объект класса Outer
## Анонимные вложенные классы
В ряде случаев удобно использовать класс без имени - анонимный класс. Если класс анонимный, то он всегда вложенный. Использование анонимных вложенных классов позволяет уменьшить размер когда
Singletons
# Дженерики
