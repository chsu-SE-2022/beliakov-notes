# Задание
Дан текстовый файл, каждая строка которого имеет предложенный ниже формат. Необходимо вывести его данные в виде таблицы, и выполнить указанную обработку. Имя файла задается пользователем. Если выбранный файл имеет иной формат, то сообщить об этом, используя механизм исключений.

В качестве интерфейса для ввода исходных данных и вывода результатов использовать web-интерфейс организованный с помощью фреймворка Vaadin. Для выбора операции организовать вертикальное меню, для расположения компонентов использовать GridLayout, у страницы должен быть заголовок, например, «Лабораторная работа №4» (стиль заголовка выбрать самостоятельно, заголовок поместить в одну из ячеек GridLayout).

Данные из файла считать двумя способами:
1. стандартное чтение из потока с помощью классов FileReader или Scanner;
2. чтение из потока в функциональном стиле, используя метод lines() класса Files.
Сообщение об исключительной ситуации также отразить на странице.
## Вариант 5
Олимпиада. Найти страну с наибольшим количеством золотых медалей, а также по запросу названий двух стран, какая из них завоевала больше очков и на сколько.  
Формат строки:  
Страна (строка из 20 символов) кол-во золотых (целое) серебряных (целое) бронзовых (целое)
# Исходный код
## FileParser.java
```java
package com.example.demo;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FileParser {
    public static ArrayList<Country> ParseFromReader(Reader reader) throws IOException {
        var bufferedReader = new BufferedReader(reader);
        String line = bufferedReader.readLine();
        ArrayList<Country> countries = new ArrayList<>();
        while (line != null) {
            countries.add(ParseLine(line));
            line = bufferedReader.readLine();
        }
        bufferedReader.close();
        reader.close();
        return countries;
    }

    public static ArrayList<Country> ParseFromFile(Path path) throws IOException {
        try (Stream<String> files = Files.lines(path)) {
            return (ArrayList<Country>) files.map(FileParser::ParseLine).collect(Collectors.toList());
        }
    }

    public static Country ParseLine(String line) throws IllegalArgumentException {
        if (line.length() < 26) {
            throw new IllegalArgumentException("Неверный формат строки");
        }
        String countryName = line.substring(0, 20).trim();
        int goldMedals = ParseMedals(line.substring(20, 22).trim());
        int silverMedals = ParseMedals(line.substring(22, 24).trim());
        int bronzeMedals = ParseMedals(line.substring(24, 26).trim());
        return new Country(countryName, goldMedals, silverMedals, bronzeMedals);
    }

    public static int ParseMedals(String substring) throws IllegalArgumentException {
        try {
            return Integer.parseInt(substring);
        } catch (NumberFormatException numberFormatException) {
            throw new IllegalArgumentException("Неверный формат медалей в строке");
        }
    }

}

```
## Country.java
```java
public class Country {
    public String CountryName;
    public int GoldMedals;
    public int SilverMedals;
    public int BronzeMedals;

    public Country(String countryName, int goldMedals, int silverMedals, int bronzeMedals) {
        CountryName = countryName;
        GoldMedals = goldMedals;
        SilverMedals = silverMedals;
        BronzeMedals = bronzeMedals;
    }

    public String getCountryName() {
        return CountryName;
    }

    public int getBronzeMedals() {
        return BronzeMedals;
    }

    public int getSilverMedals() {
        return SilverMedals;
    }

    public int getGoldMedals() {
        return GoldMedals;
    }

    public static Optional<Country> GetHighestGoldCount(ArrayList<Country> countries) {
        return countries.stream().min(new Comparator<Country>() {
            @Override
            public int compare(Country lhs, Country rhs) {
                var rhs_count = rhs.getGoldMedals();
                var lhs_count = lhs.getGoldMedals();
                return Integer.compare(rhs_count, lhs_count);
            }
        });
    }
}

```
## MainView.java
```java
public class MainView extends VerticalLayout {

    private final Grid<Country> grid = new Grid<>();
    private final ArrayList<Country> list = new ArrayList<>();
    private Country selectedRhs;
    private Country selectedLhs;
    private String winner;
    private final Text latestError = new Text("");
    private String max = "";
    private final Div comparisonDiv = new Div();
    private final Div selectionDiv = new Div();

    public MainView() {
        InitializeGrid();
        add(latestError);
        Header header = new Header(new Text("Лабораторная 4, Вариант 5"));
        add(header);
        Upload upload = CreateUpload();
        add(upload);
        add(grid);
        add(comparisonDiv);
        InitializeComparison();

        Text highest = new Text("");
        Button findHighestMedalCount = new Button("Найти страну с самым высоким числом золотых медалей");
        findHighestMedalCount.addClickListener((listener) -> {
            var c = Country.GetHighestGoldCount(list);
            c.ifPresent(country -> max = country.CountryName);
            highest.setText(max);
        });
        selectionDiv.add(findHighestMedalCount, highest);
        add(selectionDiv);
    }

    public void InitializeComparison() {
        var horizontalLayout = new HorizontalLayout();
        var lhs = InitializeListBox();
        lhs.addValueChangeListener(value -> {
            selectedLhs = value.getValue();
        });
        var rhs = InitializeListBox();
        rhs.addValueChangeListener(value -> {
            selectedRhs = value.getValue();
        });

        var button = new Button("Какая страна сильнее?");
        var text = new Text("");
        button.addClickListener(listener -> {
            try {
                int better = Integer.compare(selectedLhs.getGoldMedals(), selectedRhs.getGoldMedals());
                winner = better == -1 ? selectedRhs.getCountryName() : selectedLhs.getCountryName();
                text.setText(winner);
            } catch (NullPointerException e) {
                text.removeFromParent();
                text.setText(e.getMessage());
                add(text);
            }
        });
        horizontalLayout.add(lhs, rhs);
        comparisonDiv.add(horizontalLayout, button, text);
    }

    private ListBox<Country> InitializeListBox() {
        ListBox<Country> box = new ListBox<>();
        box.setItems(list).setIdentifierProvider(c -> c.CountryName);
        box.addValueChangeListener(l -> box.remove());
        box.setRenderer(new ComponentRenderer<Component, Country>(country -> {
            HorizontalLayout row = new HorizontalLayout();
            Span name = new Span(country.CountryName);
            row.add(name);
            return row;
        }));
        return box;
    }

    public Upload CreateUpload() {
        UploadHandler handler = (event) -> {
            list.clear();
            ArrayList<Country> countries = FileParser.ParseFromReader(new InputStreamReader(event.getInputStream()));
            list.addAll(countries);
            getUI().ifPresent(ui -> ui.access(() -> {
                grid.setItems(list);
                comparisonDiv.removeAll();
                InitializeComparison();
            }));
        };

        return new Upload(handler);
    }

    public void InitializeGrid() {
        grid.addColumn(Country::getCountryName).setHeader("Название").setAutoWidth(true);
        grid.addColumn(Country::getGoldMedals).setHeader("Золото").setAutoWidth(true);
        grid.addColumn(Country::getSilverMedals).setHeader("Серебро").setAutoWidth(true);
        grid.addColumn(Country::getBronzeMedals).setHeader("Бронза").setAutoWidth(true);
        grid.setWidth("600px");
        grid.setAllRowsVisible(true);
    }
}

```
# Алгоритм
## Считывание файлов
### Потоком
1. Создаётся `BufferedReader` из `event.getInputStream()`
2. Создаётся `ArrayList` стран
3. Пока существует следующая строка, каждая строка читается методом `ParseLine` (который разделяет строку на подстроки и конвертирует подстроки в нужные типы, собирая `Country`) и затем добавляется в список стран
4. Оба ридера закрываются и возвращается итоговый список
### Функциональная
1. Создаётся `Stream` строк из файла методом `Files.lines()`
2. Строки мапаются в `ParseLine` для конвертации в `Stream<Country>`
3. Строки собираются в `ArrayList<Country>` с помощью коллектора