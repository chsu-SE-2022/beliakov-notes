Написать приложение, которое в одном окне несколькими потоками (каждый поток своим цветом и на своем месте) рисует график функции согласно варианта

Один из способов организации приложения:

1. Добавить на форму холст (Canvas), передать в класс Picture контекст холста и производить изображение на холсте.
    
2. Класс Picture сделать, реализующей интерфейс Runnable.
    
3. Создание изображения переместить из функции paintComponent() в функцию Run().
    
4. Для запуска потоков создать функцию Start().  
      
    public void start(){  
    new Thread(this).start();  
    }

**Задание 2.**

Модифицировать приложение так, чтобы каждый поток создавал новое окно

Вариант 5
$$r = a / \phi$$
# Исходный код
```java
package org.openjfx;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Paint;
import javafx.stage.Stage;
import javafx.scene.paint.Color;

import java.io.Console;
import java.util.Objects;


/**
 * JavaFX App
 */

public class App extends Application {

    private static boolean isMultiWindow = false;

    @Override
    public void start(Stage stage) {
        if (isMultiWindow) {
            drawMultiWindow();
        }
        else {
            drawSingleWindow(stage);
        }
    }

    public void drawMultiWindow() {
        createWindow("SpiralRed", Color.RED, Math.PI / 3, 100, 100);
        createWindow("SpiralGreen", Color.GREEN, 2 * Math.PI / 3, 200, 200);
        createWindow("SpiralBlue", Color.BLUE, 0, 300, 300);
    }

    private void createWindow(String title, Paint color, double offset, int x, int y) {
        Stage newStage = new Stage();
        Canvas canvas = new Canvas(600, 600);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        gc.setFill(Color.WHITE);
        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());

        Picture picture = new Picture(gc, color, offset, x, y);
        picture.start();

        StackPane root = new StackPane(canvas);
        Scene scene = new Scene(root, 600, 600);

        newStage.setTitle(title);
        newStage.setScene(scene);
        newStage.setResizable(false);
        newStage.setX(x);
        newStage.setY(y);
        newStage.show();
    }

    public void drawSingleWindow(Stage stage) {

        Canvas canvas = new Canvas(600, 600);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        gc.setFill(Color.WHITE);
        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());

        Picture red = new Picture(gc, Color.RED, Math.PI / 3, 100, 100);
        Picture green = new Picture(gc, Color.GREEN, 2 * Math.PI / 3, 200, 200);
        Picture blue = new Picture(gc, Color.BLUE, 0, 300, 300);

        red.start();
        green.start();
        blue.start();

        StackPane root = new StackPane(canvas);
        Scene scene = new Scene(root, 600, 600);

        stage.setTitle("Test");
        stage.setScene(scene);
        stage.setResizable(false);
        stage.show();
    }

    public static void main(String[] args) {
        for (String arg : args) {
           System.out.println(arg);
        }
        if (args.length == 1 && Objects.equals(args[0], "--separate-windows")) {
            App.isMultiWindow = true;
        }
        launch();
    }
}

class Picture implements Runnable {
    private final GraphicsContext gc;
    private final Paint color;
    private final double rotationOffset;
    private final int centerX;
    private final int centerY;

    public Picture(GraphicsContext gc, Paint color, double rotationOffset, int x, int y) {
        this.gc = gc;
        this.color = color;
        this.rotationOffset = rotationOffset;
        this.centerX = x;
        this.centerY = y;
    }

    public void start() {
        new Thread(this).start();
    }

    @Override
    public void run() {
        drawSpiral();
    }

    public void drawSpiral() {
        double a = 100;

        synchronized (gc) {
            gc.setStroke(color);
            gc.setLineWidth(1.5);
            gc.beginPath();

            double startAngle = 0.1;
            double endAngle = 10 * Math.PI;
            double step = 0.01;

            boolean firstPoint = true;
            for (double phi = startAngle; phi <= endAngle; phi += step) {
                double r = a / phi;
                double x = centerX + r * Math.cos(phi + rotationOffset);
                double y = centerY + r * Math.sin(phi + rotationOffset);

                if (firstPoint) {
                    gc.moveTo(x, y);
                    firstPoint = false;
                } else {
                    gc.lineTo(x, y);
                }
            }

            gc.stroke();
        }
    }
}

```
# Алгоритм
1. Создаётся окно и графический контекст
2. Создаётся три объекта класса `Picture`
3. Каждый `Picture` в цикле высчитывает заданную формулу $r = a / \phi$, после чего высчитывает координаты x, y на основе заданного канваса
4. Затем каждый `Picture` проводит линию от предыдущей точки к полученной
5. В конце эти точки отрисовываются

Для многооконного варианта для каждого `Picture` создаётся отдельное окно и графический контекст
# Тесты
## Одно окно
![[Assets/Pasted image 20251030150841.png]]
## Много окон
![[Assets/Pasted image 20251030150919.png]]
