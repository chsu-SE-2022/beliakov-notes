Написать приложение, позволяющее создавать целочисленный бинарный файл, выводить его в многострочный редактор текстов или таблицу, а также производить указанные действия (создание, вывод и операции совсем не обязательно должны выполняться последовательно: пользователь может выбрать ранее созданный файл). Количество чисел в создаваемом файле задается случайным  образом из диапазона 1..n, где n вводится. Имя файла для создания и обработки запрашивается с помощью диалоговых окон. После создания или выбора файла его элементы выводятся. Программа должна выдавать ответ  при любых введенных пользователем данных. Интерфейс программы (используется фреймворк Vaadin), кроме оговоренных моментов произвольный, максимально удобный для пользователя и по возможности эстетичный.

# Вариант 5
Вывести по возрастанию все числа файла, которые взаимно просты с другими числами этого файла. Выводить числа дважды не нужно, даже если оно встречается несколько раз. Считывать элементы файла в массив или другую структуру нельзя, но для других целей ее создать можно. Компоненты файла вводятся с клавиатуры, диапазон вводимых чисел а..b. Считать, что число элементов файла не ограничено конкретным числом. При обработке файл можно прочитать только один раз.

# Исходный код
```java
package com.example.demo;

import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.Label;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.component.textfield.TextArea;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.router.Route;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

/**
 * The main view contains a button and a click listener.
 */
@Route("")
public class MainView extends VerticalLayout {

    private final TextArea outputArea = new TextArea("Содержимое файла");
    private final TextArea primesArea = new TextArea("Взаимно простые числа");
    private final IntegerField nField = new IntegerField("Макс количество чисел (n)");
    private final IntegerField aField = new IntegerField("Диапазон a");
    private final IntegerField bField = new IntegerField("Диапазон b");

    public MainView() {
        setSizeFull();
        setPadding(true);
        setSpacing(true);
        outputArea.setWidthFull();
        outputArea.setHeight("200px");
        primesArea.setWidthFull();
        primesArea.setHeight("150px");

        nField.setValue(100);
        aField.setValue(0);
        bField.setValue(1000);

        Button createFileBtn = new Button("Создать файл");
        Button openFileBtn = new Button("Открыть файл и показать");
        Button showPrimesBtn = new Button("Показать взаимно простые числа");

        createFileBtn.addClickListener(e -> showFileNameDialog("Создать файл", this::createFile));
        openFileBtn.addClickListener(e -> showFileNameDialog("Открыть файл", this::openFile));
        showPrimesBtn.addClickListener(e -> showFileNameDialog("Показать простые числа", this::showMutualPrimes));

        add(nField, aField, bField,
                createFileBtn, openFileBtn, showPrimesBtn,
                new Label("Содержимое файла:"), outputArea,
                new Label("Взаимнопростые числа:"), primesArea);
    }

    private void showFileNameDialog(String title, java.util.function.Consumer<String> action) {
        Dialog dialog = new Dialog();
        dialog.setWidth("300px");
        dialog.setCloseOnEsc(true);
        dialog.setCloseOnOutsideClick(false);

        TextField fileNameInput = new TextField("Имя файла");
        fileNameInput.setWidthFull();

        Button okButton = new Button("OK", event -> {
            String fileName = fileNameInput.getValue();
            if (fileName == null || fileName.trim().isEmpty()) {
                Notification.show("Введите имя файла");
                return;
            }
            dialog.close();
            action.accept(fileName.trim());
        });

        Button cancelButton = new Button("Отмена", event -> dialog.close());

        VerticalLayout layout = new VerticalLayout(new Label(title), fileNameInput, okButton, cancelButton);
        layout.setPadding(false);
        layout.setSpacing(true);
        dialog.add(layout);
        dialog.open();
    }

    private void createFile(String fileName) {
        Integer a = aField.getValue();
        Integer b = bField.getValue();

        if (a == null || b == null || a > b) {
            Notification.show("Введите корректный диапазон a <= b");
            return;
        }

        Dialog dialog = new Dialog();
        dialog.setWidth("400px");
        dialog.setCloseOnEsc(true);
        dialog.setCloseOnOutsideClick(false);

        TextArea numbersInput = new TextArea("Введите числа (по одному на строке)");
        numbersInput.setWidthFull();
        numbersInput.setHeight("200px");
        numbersInput.setPlaceholder("Например:\n10\n25\n42");

        Button saveButton = new Button("Сохранить", event -> {
            String text = numbersInput.getValue();
            if (text == null || text.trim().isEmpty()) {
                Notification.show("Введите хотя бы одно число");
                return;
            }

            try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(fileName))) {
                dos.writeInt(a);
                dos.writeInt(b);

                String[] lines = text.split("\n");
                int count = 0;
                List<String> errors = new ArrayList<>();

                for (String line : lines) {
                    line = line.trim();
                    if (line.isEmpty()) continue;

                    try {
                        int val = Integer.parseInt(line);
                        if (val < a || val > b) {
                            errors.add("Число " + val + " вне диапазона [" + a + ", " + b + "]");
                            continue;
                        }
                        dos.writeInt(val);
                        count++;
                    } catch (NumberFormatException e) {
                        errors.add("Некорректное число: " + line);
                    }
                }

                dialog.close();

                if (!errors.isEmpty()) {
                    Notification.show("Предупреждения: " + String.join(", ", errors));
                }

                if (count > 0) {
                    Notification.show("Файл создан с " + count + " элементами");
                    outputArea.clear();
                    primesArea.clear();
                } else {
                    Notification.show("Не записано ни одного корректного числа");
                }

            } catch (IOException ex) {
                Notification.show("Ошибка записи файла: " + ex.getMessage());
                dialog.close();
            }
        });

        Button cancelButton = new Button("Отмена", event -> dialog.close());

        VerticalLayout layout = new VerticalLayout(
                new Label("Введите числа в диапазоне [" + a + ", " + b + "]"),
                numbersInput,
                new HorizontalLayout(saveButton, cancelButton)
        );
        layout.setPadding(false);
        layout.setSpacing(true);

        dialog.add(layout);
        dialog.open();
    }

    private void openFile(String fileName) {
        if (!Files.exists(Paths.get(fileName))) {
            Notification.show("Файл не найден");
            return;
        }
        try (DataInputStream dis = new DataInputStream(new FileInputStream(fileName))) {
            dis.readInt();
            dis.readInt();

            StringBuilder sb = new StringBuilder();
            while (dis.available() >= 4) {
                int val = dis.readInt();
                sb.append(val).append("\n");
            }
            outputArea.setValue(sb.toString());
            primesArea.clear();
            Notification.show("Файл успешно открыт");
        } catch (IOException ex) {
            Notification.show("Ошибка чтения файла: " + ex.getMessage());
        }
    }

    private void showMutualPrimes(String fileName) {
        if (!Files.exists(Paths.get(fileName))) {
            Notification.show("Файл не найден");
            return;
        }

        try (DataInputStream dis = new DataInputStream(new FileInputStream(fileName))) {
            int a = dis.readInt();
            int b = dis.readInt();

            TreeSet<Integer> numbers = new TreeSet<>();
            TreeSet<Integer> mutualPrimes = new TreeSet<>();

            while (dis.available() >= 4) {
                int current = dis.readInt();
                numbers.add(current);

            }
            mutualPrimes = (TreeSet<Integer>) findCoprimeSet(numbers);
//            for (Integer current : numbers) {
//                boolean isMutualPrime = true;
//                for (int other : numbers) {
//                    if (current != other && current != 1) {
//                        var gcd = gcd(current, other);
//                        if (gcd != 1 && gcd != current) {
//                            isMutualPrime = false;
//                            break;
//                        }
//                    }
//                }
//                if (isMutualPrime) {
//                    System.out.println("Adding " + current);
//                    mutualPrimes.add(current);
//                } else {
//                    System.out.println(current + " is not a mutual prime with other numbers");
//                }
//            }
            StringBuilder sb = new StringBuilder();
            for (Integer num : mutualPrimes) {
                sb.append(num).append("\n");
            }

            primesArea.setValue(sb.isEmpty() ? "Нет взаимно простых чисел" : sb.toString());

        } catch (IOException ex) {
            Notification.show("Ошибка обработки файла: " + ex.getMessage());
        }
    }

    private Set<Integer> findCoprimeSet(Set<Integer> numbers) {
        List<Integer> numList = new ArrayList<>(numbers);

        numList.sort((a, b) -> findPrimeFactors(a).size() - findPrimeFactors(b).size());

        Set<Integer> result = new TreeSet<>();
        Set<Integer> usedPrimes = new TreeSet<>();

        for (int num : numList) {
            Set<Integer> factors = findPrimeFactors(num);

            boolean disjoint = true;
            for (int factor : factors) {
                if (usedPrimes.contains(factor)) {
                    disjoint = false;
                    break;
                }
            }

            if (disjoint) {
                result.add(num);
                usedPrimes.addAll(factors);
            }
        }
        return result;
    }

    private Set<Integer> findPrimeFactors(int n) {
        Set<Integer> factors = new TreeSet<>();

        while (n % 2 == 0) {
            factors.add(2);
            n /= 2;
        }

        for (int i = 3; i * i <= n; i += 2) {
            while (n % i == 0) {
                factors.add(i);
                n /= i;
            }
        }

        if (n > 2) {
            factors.add(n);
        }

        return factors;
    }

    private int gcd(int initA, int initB) {
        System.out.println("GCD of " + initA + " and " + initB);
        var a = Math.abs(initA);
        var b = Math.abs(initB);
        if (a == b) {
            return a;
        }
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
й
```
# Алгоритм
1. Считываем из файла список уникальных чисел в Set `unique`
2. Сортируем `unique` по количеству простых множителей
3. Создаём Set `usedPrimes`
4. Для каждого числа находим его простые множители. Если они не пересекаются с `usedPrimes`, заносим число в список взаимнопростых, а его простые множители - в `usedPrimes`
5. Выводим список взаимнопростых

# Пример
## Подготовка
`unique (set) = [2, 3, 4, 5, 6, 7, 8, 9]`

сортируем unique по количеству простых множителей
## 2
```
usedPrimes (set) = []
result (set) = []

простые множители от 2 (factors) = [2]
usedPrimes не содержит элементов из factors, заносим 2 в result и factors в usedPrimes


```
## 3
```
usedPrimes (set) = [2]
result (set) = [2]

простые множители от 3 (factors) = [3]
usedPrimes не содержит элементов из factors, заносим 3 в result и factors в usedPrimes
```
## 4
```
usedPrimes (set) = [2, 3]
result (set) = [2, 3]

простые множители от 4 (factors) = [2, 2]
usedPrimes содержит элементы из factors (2) => 4 не заносится в result

```
## 5
```
usedPrimes (set) = [2, 3]
result (set) = [2, 3]

простые множители от 5 (factors) = [5]
usedPrimes не содержит элементов из factors, заносим 5 в result и factors в usedPrimes
```
## 6
```
usedPrimes (set) = [2, 3, 5]
result (set) = [2, 3, 5]

простые множители от 6 (factors) = [2, 3]
usedPrimes содержит элементы из factors (2, 3) => 6 не заносится в результат 
```
## 7
```
usedPrimes (set) = [2, 3, 5]
result (set) = [2, 3, 5]

простые множители от 7 (factors) = [7]
usedPrimes не содержит элементов из factors, заносим 7 в result и factors в usedPrimes
```
## 8
```
usedPrimes (set) = [2, 3, 5, 7]
result (set) = [2, 3, 5, 7]

простые множители от 8 (factors) = [2, 2, 2]
usedPrimes содержит элементы из factors (2) => 8 не заносится в результат 
```
## 9
```
usedPrimes (set) = [2, 3, 5, 7]
result (set) = [2, 3, 5, 7]

простые множители от 9 (factors) = [3, 3]
usedPrimes содержит элементы из factors (3) => 9 не заносится в результат 
```
## Вывод
Выводим все занесённые в result значения
# Результат
![[Assets/Pasted image 20251016144416.png]]