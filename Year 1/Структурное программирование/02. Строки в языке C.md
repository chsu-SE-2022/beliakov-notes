## Строки
Для представления строк в языке C используются массивы типа `char`. Это единственный вид массива, который можно вводить и выводить не по циклу.
```
char str1[100] = "Text1";
// Примечание - Позиции с 5 по 99 будут заполнены ноль-символами
char str2[] = "Text2";
char str3[] = {'T','e','x','t','3','\0'};
char *str4 = "Text4";
```
Признаком конца строки является так называется *ноль-символ* - символ с кодом `0`. 
Если при инициализации (примеры 1, 2, 4) или при вводе строка задаётся целиком, нулевой символ добавляется автоматически. 
Если же массив типа `char` задаётся поэлементно (пример 3), то ноль-символ указывается явно.
В примере 4 видно, что строку можно хранить через указатель. Аналогично одномерному динамическому массиву. 
Помимо управляющего ноль-символа - признака конца строки - могут присутствовать и другие:
\\a - звонок;
\\t - горизонтальная табуляция;
\\r - возврат каретки;
\\n - перевод строки;
\\b - "забой" (backspace);
\\' - апостроф;
\\" - двойная кавычка
\\\\ - обратный слэш;
\\0 - ноль-символ
## Ввод-вывод
#### Ввод:
```
cin >> dest;
char* gets(char* dest);
// Для gets строка должна быть изначально инициализирована
```
#### Вывод:
```
cout << dest;
int puts(const char* src);
```
## Методы для строк
Для работы со строками в языке С существует ряд стандартных функций
```
char* strcpy(char* dest, const char* src);
int strlen(const char* src);
char* strcat(char* dest, const char* src);
```
#### Примеры
Дана строка, переписать её в обратном порядке
```
char str1[100] = "123456789", str2[100];
int n = strlen(str1);
for (int i = 0; i < n; i++) {
	str2[n - i - 1] = str1[i];
}
str[n]='\0';
cout << str2;
```
#### Методы
```
// Находит первое вхождение символа chr в src и возвращает указатель на подстроку, начинающуюся с найденного символа
char* strchr(const char* src, char chr);
// Последнее вхождение
char* strrchr(const char* src, char chr);
// Первое вхождение строки
char* strstr(const char* str, const char* substr);
// Сравнивает строки str1 и str2 и возвращает 0 при их равенстве, иначе разность кодов (в C99) или -1 и +1 в зависимости от бОльшей строки (C16)
int strcmp(const char* str1, const char* str2);
```
```
/* Выделяет из src отдельные слова (токены), изпользуя в качестве разделителей символы seps. src - указатель на строку, seps - указатель на сепараторы, возвращает указатель на первую букву получившегося слова. 
strtok(string, separator) - находит первый не равный сепаратору символ, затем первый равный сепаратору символ, вместо сепаратора вставляет null-символ
	strtok(NULL, separator) - "двигает" функцию дальше
*/ 
char* strtok(char* src, const char* seps);
// argument to integer
int atoi(const char* str);
// argument to float
int atof(const char* str);
// integer to argument, radix - основание системы счисления
char* _itoa(int number, char* dest, int radix);
// float to argument
char* _gcvt(double number, int num_dig, char* dest);
```

#### Примеры
Дана строка, состоящая из слов, разделённых пробелами. Найти количество слов в строке
```
char str[100] = "Anna Anton Maxim";
int k = 0;
for (int i = 0; i < strlen(str1); i++) {
	if (str1[i] == ' ');
	k++;
}
// Не работает при лишних пробелах
for (int i = 0; i < strlen(str1); i++) {
	if (str1[i] != ' ' && str[i+1} == ' ']);
	k++;
}
// Не работает при других сепараторах
char separators[] = " ,!";
char *token = strtok(str1, separators);
while(token != null) {
	cout << token << endl;
	k++;
	token = strtok(NULL, separators); // 
}
cout << k << endl;
```
Дана строка, состоящая из слов. Определить, сколько слов представляют собой двоичные числа
