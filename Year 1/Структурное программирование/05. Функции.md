Парадигма - модель постановки проблем, принятая в качестве образца решения исследовательских задач; господствующий способ научного мышления
**Парадигма программирования** - комплекс концепций, принципов, абстракций, определяющий фундамент стиля программирования
##### Парадигмы программирования
- Процедурное программирование (FORTRAN)
- Функциональное программирование (Lisp)
- Структурное программирование (Pascal)
- Логическое программирование (PROLOG)
- ООП (C++)
##### Принципы структурного программирования
1. У любой программы три базовые управляющие конструкции: последствие, ветвление, цикл
2. В программе базовые конструкции можно вложить друг в друга
3. Повторяющиеся фрагменты программы можно оформить в виде подпрограмм (функций)
4. Каждую логически законченную группу инструкций следует оформить как блок
5. Все конструкции должны иметь один вход и один выход
6. Разработка программы идёт сверху вниз

### Функции
#### Общий вид
```
class type name (params) [throws] {
body
}
```
`int sum(int a, int b` - объявление
`int sum(int a, int b) { return a+b; }` - определение
**Функция** - именованная последовательность описаний и операторов, выполняющая некоторое законченное действие. Функция  может принимать параметры и возвращать результаты. Любая программа на С состоит из функций, одна из которых обязательно `main`.  Любая функция должна быть объявлена и определена (called and declared).  Объявление функции должно быть раньше её определения. Оно также называется прототипом, заголовком или сигнатурой функции. Определение функции кроме заголовка содержит тело функции
##### Составные части определения
1. С помощью необязательного модификаторы `class`  можно явно задать область видимости функции
`extern` - глобальная видимость функции во всех модулях программы, используется по умолчанию
`static` - видимость в пределах модуля, в котором определена функция
2. `type` возвращаемого значения может быть любым, кроме `array` и `function`, но может быть указателем на массив  или функцию. Если функция не возвращает никаких значений, она описывается типом `void` и становится процедурой
3. Если используется модификатор `extern`, `name` должно быть уникальным
4. Список параметров `params` определяет величины, которые следует передать в функцию при её вызове, а также возможно результаты, которые функция будет возвращать
5. В заголовке функции можно задать список исключений `Exception`, которые эта функция будет косвенно или прямо порождать
### Переменные
Переменные, описанные внутри функции, являются локальными, и могут использоваться только в этой функции
Переменные, описанные в программе до заголовков функций, называются глобальными, и могут использоваться в любой функции этой программы

### Параметры функции
Механизм параметра является основным способом между вызывающей и выполняющей функциями. Существует три вида передачи параметров в функцию
- По значению
- По адресу
- По ссылке
##### Передача по значению
В случае передачи по значению параметры описываются как обычные переменные. В функцию передаётся значение из места вызова, под которое внутри функции отводится своя ячейка памяти. Фактически производится копирование значения параметра. Даже если такой параметр внутри функции будет изменён, его "собрат" при вызове останется прежним
##### Передача по адресу
Параметр внутри функции описывается как указатель и из места вызова ему передаётся не значение, а адрес некоторой ячейки памяти.
При изменении значения разыменованного указателя в функции, изменится значение в точке вызова.
##### Передача по ссылке
Ссылочная переменная это альтернативное имя некоторой другой переменной того же типа. Ссылочная переменная описывается как `type& name` и при описании ссылки сразу нужно присвоить некоторое значение, которое в дальнейшем изменить будет нельзя
```
int a = 7;
int& b = a;
b *= 3;
a *= 2;
// a == 42
```
### Формальные и фактические параметры
Параметры, описанные в заголовке функции, называются **формальными**, так как изначально они не имеют никаких значений, и лишь в теле функции формально показывается, что с этими параметрами должна делать функция. Их "собратья" при вызове называются **фактическими**, так как они передают фактические значения формальным параметрам
### Рекурсия
Любую функцию можно вызвать внутри любой другой. Отдельный интерес вызывает обращение функции внутри самой этой функции. Такое обращение называется **рекурсией**
```
void f() {
	f();
}
```
Чтобы в рекурсивной функции не получилось достичь `StackOverflow`,  в неё добавляют параметр, который при каждом следующем вызове изменяется, и по достижении некоторого значения рекурсивный вызов прекращается

###### Stack
Область памяти по принципу first in - last out

Рекурсивной может быть не только функция, но и процедура

### Передача в функцию массивов
#### Одномерные массивы
В качестве параметра используется указатель на первый элемент массива, но функция сама по себе количество элементов не знает, поэтому вторым параметром передаётся размер массива
```
int sum(int *arr, int size) {
int s = 0;
for (int i = 0; i < size; i++) {
	s+=a[i];
}
return s;
}
int a[n] = {};
```
#### Двумерные массивы
В случае двумерного массива есть разница при передаче динамических и статических массивов.
##### Динамические массивы
В случае динамических массивов, массив передаётся через двойной указатель с указанием двух дополнительных параметров (числа строк и числа столбцов)
```
int sum(int** a, int n1, int n2) {
	int s = 0;
	for(int i = 0; i < n1; j++) {
		for (int j = 0; j < n2; j++) {
		s += a[i][j];
		}
	}
	return s;
}
int main() {
	int n1 = 3; int n2 = 3
	int **a = new int*[n1];
	for (int i = 0; i < n1; i++) {
		a[i] = new int[n2];
	}
	for(int i = 0; i < n1; j++) {
		for (int j = 0; j < n2; j++) {
		a[i][j]=i;
		}
	}
	cout << sum(a, n1, n2) << endl;

}
```
##### Статические массивы
Статический двумерный массив может быть передан только через указатель, но в этом случае он будет рассматриваться в функции как одномерный массив с количеством элементов `n1*n2` и доступ к элементам массива по двойному индексу невозможен. Однако, из-за того, что элементы хранятся один за другим (построчно), можно организовать пересчёт индексов из двумерного в одномерный массив
```
int sum(int** a, int n1, int n2) {
	int s = 0;
	for(int i = 0; i < n1; j++) {
		for (int j = 0; j < n2; j++) {
			// не можем обращаться по двойному индексу
			s += a[i*n2+j];
		}
	}
	return s;
}
int main() {
	int n1 = 3; int n2 = 3
	int a[n1][n2] = {{1,1},{2,2},{3,3}};
	for (int i = 0; i < n1; i++) {
		a[i] = new int[n2];
	}
	for(int i = 0; i < n1; j++) {
		for (int j = 0; j < n2; j++) {
		a[i][j]=i;
		}
	}
	cout << sum(&a[0][0], n1, n2) << endl;

}
```
### Параметры по умолчанию
Чтобы упростить вызов функции, в её заголовке можно указать значения некоторых параметров по умолчанию. Эти параметры должны быть последними в списке и могут опускаться при вызове функции. Если опущен один, то должны быть опущены и остальные
```
int sum(int a = 2, int b = 5) {

}
```
### Заголовочные файлы
**Заголовочный файл** - файл, чаще всего содержащий заголовки некоторых функций. В нём можно также описать и тело каждой функции, но как правило описание в другой файл. Для подключения созданного заголовочного файла используется директива `#include`, но так как созданный заголовочный файл обычно находится в той же папке, что и файл основной программы, то его имя берётся в кавычках (`#include 'library'`).
### Перегрузка функций
Описание двух и более функций с одинаковым именем, но разным по количеству или типу набором параметров называется перегрузкой функции. Компилятор определяет какую из функций выбрать по набору фактических параметров при вызове.
```
double perimeter(double a) {
	return 4 * a;
}
double perimeter(double a, double b) {
	return 2 * (a + b);
}
double perimeter(double a, double b, double c) {
	return a + b + c;
}
```

