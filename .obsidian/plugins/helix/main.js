/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HelixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/codemirror-helix/dist/lib.js
var import_commands = require("@codemirror/commands");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_search = require("@codemirror/search");
var import_language = require("@codemirror/language");
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_search2 = require("@codemirror/search");
var modeEffect = import_state2.StateEffect.define();
var modeField = import_state2.StateField.define({
  create() {
    return {
      type: 0,
      minor: 2
      /* Normal */
    };
  },
  update(mode, tr) {
    for (const effect of tr.effects) {
      if (effect.is(modeEffect)) {
        mode = effect.value;
      }
    }
    return mode;
  }
});
function sameMode(mode, otherMode) {
  return mode.type === otherMode.type && mode.minor === otherMode.minor;
}
var yankEffect = import_state2.StateEffect.define();
var registerField = import_state2.StateField.define({
  create() {
    return "";
  },
  update(register, tr) {
    for (const effect of tr.effects) {
      if (effect.is(yankEffect)) {
        register = effect.value;
      }
    }
    return register;
  }
});
var searchRegisterField = import_state2.StateField.define({
  create() {
    return { active: null };
  },
  update(search2, tr) {
    var _a;
    for (const effect of tr.effects) {
      if (effect.is(searchEffect)) {
        const effectValue = effect.value;
        switch (effectValue.type) {
          case 0: {
            search2 = { ...search2, original: effectValue.selection };
            break;
          }
          case 1: {
            search2 = {
              original: void 0,
              active: (_a = effectValue.query) != null ? _a : search2.active
            };
            break;
          }
        }
      }
    }
    return search2;
  }
});
var searchEffect = import_state2.StateEffect.define();
var historyEffect = import_state2.StateEffect.define();
var historyField = import_state2.StateField.define({
  create() {
    return { checkpoints: [], cursor: -1, pending: null, head: null };
  },
  update(value, tr) {
    var _a, _b;
    for (const effect of tr.effects) {
      if (effect.is(historyEffect)) {
        const effectValue = effect.value;
        switch (effectValue.type) {
          case "move": {
            const cursor = value.cursor + effectValue.offset;
            value = {
              checkpoints: value.checkpoints,
              pending: null,
              cursor,
              head: (_b = (_a = value.head) != null ? _a : effectValue.head) != null ? _b : null
            };
            break;
          }
          case "add": {
            if (false) {
              if (value.pending && effectValue.temp) {
                throw new Error("Unexpected temp");
              }
            }
            const checkpoints = value.cursor === -1 ? value.checkpoints : value.checkpoints.slice(value.cursor + 1);
            value = effectValue.temp ? {
              checkpoints: value.checkpoints,
              cursor: value.cursor,
              pending: effectValue.state,
              head: value.head
            } : {
              checkpoints: [effectValue.state, ...checkpoints],
              cursor: -1,
              pending: null,
              head: null
            };
            break;
          }
          case "commit": {
            if (false) {
              if (!value.pending) {
                throw new Error("unexpected commit");
              }
            }
            if (effectValue.state.doc.eq(value.pending.doc)) {
              value = {
                ...value,
                pending: null
              };
              break;
            }
            const checkpoints = value.cursor === -1 ? value.checkpoints : value.checkpoints.slice(value.cursor + 1);
            value = {
              checkpoints: [value.pending, ...checkpoints],
              cursor: -1,
              pending: null,
              head: null
            };
            break;
          }
        }
      }
    }
    return value;
  }
});
var panelStyles = import_view2.EditorView.theme({
  ".cm-hx-status-panel": {
    display: "flex",
    "justify-content": "space-between",
    "font-family": "monospace"
  },
  ".cm-hx-command-panel": {
    display: "flex",
    justifyContent: "space-between",
    fontFamily: "monospace",
    minHeight: "18px"
  },
  ".cm-hx-command-input": {
    border: "none",
    outline: "none",
    padding: "0",
    margin: "0",
    background: "inherit"
  },
  ".cm-hx-command-popup": {
    position: "fixed",
    background: "#ccc"
  },
  ".cm-hx-command-help": {
    border: "1px solid #777",
    background: "#ddd",
    padding: "2px",
    whiteSpace: "preserve"
  }
});
var CommandPanel = class {
  constructor(view, facet, addSearch2) {
    __publicField(this, "dom");
    __publicField(this, "minorCommand");
    __publicField(this, "inputContainer");
    __publicField(this, "label");
    __publicField(this, "message", false);
    __publicField(this, "commandPopup");
    __publicField(this, "autocomplete");
    __publicField(this, "help");
    __publicField(this, "popupRequest");
    this.view = view;
    this.facet = facet;
    this.addSearch = addSearch2;
    this.dom = el("div");
    this.minorCommand = el("span");
    this.inputContainer = el("span");
    this.commandPopup = el("div");
    this.dom.insertBefore(this.inputContainer, null);
    this.dom.insertBefore(this.minorCommand, null);
    this.dom.insertBefore(this.commandPopup, null);
    this.dom.classList.add("cm-hx-command-panel");
    this.inputContainer.style.visibility = "hidden";
    this.label = el("span");
    this.inputContainer.insertBefore(this.label, null);
    this.commandPopup.classList.add("cm-hx-command-popup");
    this.help = el("div");
    this.autocomplete = el("div");
    this.help.hidden = true;
    this.help.classList.add("cm-hx-command-help");
    this.autocomplete.classList.add("cm-hx-command-autocomplete");
    this.commandPopup.insertBefore(this.help, null);
    this.commandPopup.insertBefore(this.autocomplete, null);
    this.minorCommand.style.minWidth = "8em";
    this.minorCommand.style.textAlign = "center";
  }
  showSearchInput() {
    const input = this.searchInput();
    this.showInput(input, "search:");
  }
  showCommandInput() {
    const input = this.commandInput();
    this.showInput(input, ":");
  }
  showMinor(command) {
    if (command) {
      this.minorCommand.textContent = command;
    } else {
      this.minorCommand.innerHTML = "&nbsp;";
    }
  }
  showInput(input, label) {
    this.label.textContent = label;
    this.label.style.color = "";
    this.inputContainer.insertBefore(input, null);
    this.inputContainer.style.visibility = "";
    input.focus();
  }
  createInput({
    onInput,
    onClose
  }) {
    const input = el("input");
    input.classList.add("cm-hx-command-input");
    input.type = "text";
    input.addEventListener("blur", () => onClose(false, input.value));
    input.addEventListener("input", () => {
      onInput(input.value);
    });
    input.addEventListener("keydown", (event) => {
      if (event.isComposing) {
        return;
      }
      const isEnter = event.key === "Enter";
      if (isEnter || event.key === "Escape") {
        onClose(isEnter, input.value);
      }
    });
    return input;
  }
  commandInput() {
    const { view } = this;
    return this.createInput({
      onClose: (commit, value) => {
        this.hidePopup();
        const [cmd, ...args] = value.split(/ +/);
        if (commit && cmd) {
          const commands = view.state.facet(this.facet);
          const command = commands.find(
            (command2) => {
              var _a;
              return command2.name === cmd || ((_a = command2.aliases) == null ? void 0 : _a.some((alias) => alias === cmd));
            }
          );
          const result = command ? command.handler(view, args) : {
            message: `no such command: '${cmd}'`,
            error: true
          };
          if (result) {
            this.showMessageAndCloseInput(result.message, result.error);
            return;
          }
        }
        this.closeInput();
      },
      onInput: (value) => {
        const cmd = value.split(/ +/).at(0);
        if (!cmd) {
          this.hidePopup();
          return;
        }
        const commands = view.state.facet(this.facet);
        const options = commands.filter(
          (command) => {
            var _a;
            return command.name.startsWith(cmd) || ((_a = command.aliases) == null ? void 0 : _a.some((alias) => alias.startsWith(cmd)));
          }
        );
        if (options.length === 0) {
          this.hidePopup();
          return;
        }
        const match = options.find(
          (command) => {
            var _a;
            return command.name === cmd || ((_a = command.aliases) == null ? void 0 : _a.some((alias) => alias === cmd));
          }
        );
        this.showPopup(options, match);
      }
    });
  }
  showMessage(message, error) {
    this.inputContainer.style.visibility = "";
    this.message = true;
    this.label.style.color = error ? "red" : "";
    this.label.textContent = message;
  }
  showMessageAndCloseInput(message, error) {
    this.showMessage(message, error);
    this.closeInput(false);
  }
  hasMessage() {
    return this.message;
  }
  clearMessage() {
    if (this.message) {
      this.message = false;
      this.label.textContent = "";
      this.inputContainer.style.visibility = "hidden";
    }
  }
  showPopup(commands, match) {
    var _a;
    this.commandPopup.hidden = false;
    this.help.hidden = !match;
    if (match) {
      this.help.textContent = `${match.help}`;
      if (match.aliases && match.aliases.length > 0) {
        this.help.textContent += `
Aliases: ${match.aliases.join(",")}`;
      }
    } else {
      this.help.textContent = "";
    }
    while (commands.length > this.autocomplete.childNodes.length) {
      const entry = el("span");
      entry.style.marginRight = "1em";
      this.autocomplete.insertBefore(entry, null);
    }
    for (const [i, child] of this.autocomplete.childNodes.entries()) {
      const command = commands[i];
      if (command) {
        child.textContent = command.name;
      } else {
        break;
      }
    }
    while (this.autocomplete.childNodes.length > commands.length) {
      (_a = this.autocomplete.lastChild) == null ? void 0 : _a.remove();
    }
    if (this.popupRequest == null) {
      this.popupRequest = requestAnimationFrame(() => this.positionPopup());
    }
  }
  hidePopup() {
    this.commandPopup.hidden = true;
  }
  positionPopup() {
    this.popupRequest = void 0;
    if (this.commandPopup.hidden) {
      return;
    }
    const box = this.inputContainer.getBoundingClientRect();
    this.commandPopup.style.bottom = `${window.innerHeight - box.top}px`;
    this.commandPopup.style.left = `${box.left}px`;
  }
  searchInput() {
    const { view } = this;
    return this.createInput({
      onClose: (commit) => {
        this.closeSearchInput(commit);
      },
      onInput: (value) => {
        const query = new import_search2.SearchQuery({
          search: value,
          regexp: true,
          caseSensitive: false
        });
        const effect = import_search2.setSearchQuery.of(query);
        view.dispatch({ effects: effect });
        this.addSearch(view, query);
      }
    });
  }
  closeSearchInput(accept) {
    this.view.dispatch({
      effects: [
        searchEffect.of({
          type: 1,
          query: accept ? (0, import_search2.getSearchQuery)(this.view.state) : void 0
        }),
        import_search2.setSearchQuery.of(new import_search2.SearchQuery({ search: "" }))
      ]
    });
    this.closeInput();
  }
  closeInput(hide = true) {
    this.inputContainer.removeChild(this.inputContainer.lastChild);
    if (hide) {
      this.inputContainer.style.visibility = "hidden";
    }
    requestAnimationFrame(() => {
      this.view.focus();
    });
  }
};
function statusPanel(view) {
  const dom = el("div");
  dom.classList.add("cm-hx-status-panel");
  const mode = el("span");
  mode.textContent = "NOR";
  dom.insertBefore(mode, null);
  const pos = el("span");
  dom.insertBefore(pos, null);
  function setLineCol() {
    const { line, column } = lineCol(view);
    pos.textContent = `${line}:${column}`;
  }
  setLineCol();
  return {
    dom,
    setMode(modeStr) {
      mode.textContent = modeStr;
    },
    setLineCol
  };
}
function lineCol(view) {
  const head = view.state.selection.main.head;
  const lineDesc = view.state.doc.lineAt(head);
  const line = lineDesc.number;
  const column = head - lineDesc.from + 1;
  return { line, column };
}
function el(tag) {
  return document.createElement(tag);
}
var MODE_EFF = {
  NORMAL: modeEffect.of({
    type: 0,
    minor: 2
    /* Normal */
  }),
  NORMAL_GOTO: modeEffect.of({
    type: 0,
    minor: 3
    /* Goto */
  }),
  NORMAL_MATCH: modeEffect.of({
    type: 0,
    minor: 5
    /* Match */
  }),
  NORMAL_SPACE: modeEffect.of({
    type: 0,
    minor: 6
    /* Space */
  }),
  SELECT: modeEffect.of({
    type: 4,
    minor: 2
    /* Normal */
  }),
  SELECT_GOTO: modeEffect.of({
    type: 4,
    minor: 3
    /* Goto */
  }),
  SELECT_MATCH: modeEffect.of({
    type: 4,
    minor: 5
    /* Match */
  }),
  SELECT_SPACE: modeEffect.of({
    type: 4,
    minor: 6
    /* Space */
  }),
  INSERT: modeEffect.of({
    type: 1
    /* Insert */
  })
};
function moveBy(view, mode, cursor, select) {
  if (mode.type === 4) {
    select(view);
    return;
  }
  const selection = view.state.selection.main;
  if (selection.from !== selection.to) {
    view.dispatch({
      selection: import_state.EditorSelection.cursor(selection.head)
    });
  }
  cursor(view);
}
function moveDown(view, mode) {
  moveBy(view, mode, import_commands.cursorLineDown, import_commands.selectLineDown);
}
function moveUp(view, mode) {
  moveBy(view, mode, import_commands.cursorLineUp, import_commands.selectLineUp);
}
function moveLeft(view, mode) {
  moveBy(view, mode, import_commands.cursorCharLeft, import_commands.selectCharLeft);
}
function moveRight(view, mode) {
  moveBy(view, mode, import_commands.cursorCharRight, import_commands.selectCharRight);
}
function addSearch(view, query) {
  var _a;
  let match;
  const searchRegister = view.state.field(searchRegisterField);
  if (query.valid) {
    match = query.getCursor(
      view.state,
      ((_a = searchRegister.original) != null ? _a : view.state.selection).main.to
    ).next();
  }
  if (match && !match.done) {
    view.dispatch({
      selection: import_state.EditorSelection.range(match.value.from, match.value.to),
      scrollIntoView: true
    });
  } else {
    view.dispatch({
      selection: searchRegister.original,
      scrollIntoView: true
    });
  }
}
var helixCommandBindings = {
  insert: {
    Backspace(view) {
      (0, import_commands.deleteCharBackward)(view);
    },
    Delete(view) {
      (0, import_commands.deleteCharForward)(view);
    },
    Enter(view) {
      (0, import_commands.insertNewlineAndIndent)(view);
    },
    Escape(view) {
      view.dispatch({
        effects: [
          MODE_EFF.NORMAL,
          historyEffect.of({ type: "commit", state: view.state })
        ]
      });
    }
  },
  normal: {
    // this one is special: we let it apply to all other minor modes
    Escape(view, mode_) {
      const mode = mode_;
      if (mode.type === 0 && mode.minor === 2 && mode.expecting == null) {
        return true;
      }
      view.dispatch({
        effects: [MODE_EFF.NORMAL]
      });
      if (mode.expecting) {
        const panel = getHelixPanel(view, commandPanel);
        panel.showMinor(null);
      }
    },
    ["/"](view) {
      view.dispatch({
        effects: searchEffect.of({
          type: 0,
          selection: view.state.selection
        })
      });
      view.dispatch({
        effects: import_search.setSearchQuery.of(new import_search.SearchQuery({ search: "" }))
      });
      const panel = getHelixPanel(view, commandPanel);
      panel.showSearchInput();
    },
    [":"](view) {
      const panel = getHelixPanel(view, commandPanel);
      panel.showCommandInput();
    },
    ["y"](view) {
      const selection = view.state.selection.main;
      const range = helixSelection(selection, view.state.doc);
      view.dispatch({
        effects: yankEffect.of(view.state.doc.slice(range.from, range.to))
      });
      getHelixPanel(view, commandPanel).showMessage(
        'yanked 1 selection to register "'
      );
    },
    ["a"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(selection.to)
        });
      }
    },
    ["A"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const end = view.state.doc.lineAt(selection.to).to;
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(end)
        });
      }
    },
    ["I"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const start = view.state.doc.lineAt(selection.from).from;
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(start)
        });
      }
    },
    ["c"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const range = helixSelection(selection, view.state.doc);
        view.dispatch({
          effects: [
            yankEffect.of(view.state.doc.slice(range.from, range.to)),
            MODE_EFF.INSERT
          ],
          changes: {
            from: range.from,
            to: range.to,
            insert: ""
          }
        });
      }
    },
    ["d"]: {
      checkpoint: true,
      command(view) {
        const selection = view.state.selection.main;
        const range = helixSelection(selection, view.state.doc);
        view.dispatch({
          effects: [
            yankEffect.of(view.state.doc.slice(range.from, range.to)),
            MODE_EFF.NORMAL
          ],
          changes: {
            from: range.from,
            to: range.to
          }
        });
      }
    },
    ["P"]: {
      checkpoint: true,
      command(view) {
        const yanked = view.state.field(registerField);
        paste(view, yanked, false);
      }
    },
    ["p"]: {
      checkpoint: true,
      command(view) {
        const yanked = view.state.field(registerField);
        paste(view, yanked, true);
      }
    },
    ["R"]: {
      checkpoint: true,
      command(view) {
        const tr = view.state.replaceSelection(view.state.field(registerField));
        tr.effects = MODE_EFF.NORMAL;
        view.dispatch(tr);
      }
    },
    ["r"]: {
      checkpoint: true,
      command(view, mode) {
        view.dispatch({
          effects: modeEffect.of({
            ...mode,
            expecting: {
              callback: replaceWithChar,
              metadata: view
            }
          })
        });
        getHelixPanel(view.original, commandPanel).showMinor("r");
      }
    },
    ["w"](view, mode) {
      if (mode.type === 0) {
        const current = view.state.selection.main;
        view.dispatch({
          selection: import_state.EditorSelection.single(Math.max(current.from, current.to))
        });
      }
      return (0, import_commands.selectGroupRight)(view);
    },
    ["b"](view, mode) {
      if (mode.type === 0) {
        const current = view.state.selection.main;
        view.dispatch({
          selection: import_state.EditorSelection.single(Math.min(current.from, current.to))
        });
      }
      return (0, import_commands.selectGroupLeft)(view);
    },
    ["v"](view, mode) {
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.SELECT : MODE_EFF.NORMAL
      });
    },
    ["g"](view, mode) {
      const isNormal = mode.type === 0;
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL_GOTO : MODE_EFF.SELECT_GOTO
      });
      getHelixPanel(view, commandPanel).showMinor("g");
    },
    ["Space"](view, mode) {
      const isNormal = mode.type === 0;
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL_SPACE : MODE_EFF.SELECT_SPACE
      });
      getHelixPanel(view, commandPanel).showMinor("<space>");
    },
    ["m"](view, mode) {
      const isNormal = mode.type === 0;
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL_MATCH : MODE_EFF.SELECT_MATCH
      });
      getHelixPanel(view, commandPanel).showMinor("m");
    },
    ["i"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const cursor = Math.min(selection.from, selection.to);
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(cursor)
        });
      }
    },
    ["h"](view, mode) {
      return moveLeft(view, mode);
    },
    ["j"]: moveDown,
    ["ArrowDown"]: "j",
    ["ArrowUp"]: "k",
    ["k"]: moveUp,
    ["ArrowRight"]: "l",
    ["ArrowLeft"]: "h",
    ["l"](view, mode) {
      return moveRight(view, mode);
    },
    ["%"](view) {
      return (0, import_commands.selectAll)(view);
    },
    ["o"]: {
      checkpoint: "temp",
      command(view) {
        insertLineAndEdit(view, true);
      }
    },
    ["O"]: {
      checkpoint: "temp",
      command(view) {
        insertLineAndEdit(view, false);
      }
    },
    ["f"](view, mode) {
      setFindMode(view, "f", mode, {
        inclusive: true,
        reverse: false
      });
    },
    ["F"](view, mode) {
      setFindMode(view, "F", mode, {
        inclusive: true,
        reverse: true
      });
    },
    ["t"](view, mode) {
      setFindMode(view, "t", mode, {
        inclusive: false,
        reverse: false
      });
    },
    ["T"](view, mode) {
      setFindMode(view, "T", mode, {
        inclusive: false,
        reverse: true
      });
    },
    ["u"](view) {
      const { checkpoints, cursor } = view.state.field(historyField);
      const nextCursor = cursor + 1;
      const state = checkpoints[nextCursor];
      if (!state) {
        return true;
      }
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: state.doc
        },
        selection: state.selection,
        effects: historyEffect.of({
          type: "move",
          offset: 1,
          head: view.state
        }),
        scrollIntoView: true
      });
    },
    ["U"](view) {
      const { checkpoints, cursor, head } = view.state.field(historyField);
      const nextCursor = cursor - 1;
      const state = nextCursor === -1 ? head : checkpoints[nextCursor];
      if (!state) {
        return true;
      }
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: state.doc
        },
        selection: state.selection,
        effects: historyEffect.of({
          type: "move",
          offset: -1
        }),
        scrollIntoView: true
      });
    },
    ["x"](view) {
      const initial = view.state.selection.main;
      const anchorLine = view.state.doc.lineAt(initial.anchor);
      const headLine = view.state.doc.lineAt(initial.head);
      const [startLine, endLine] = anchorLine.number < headLine.number ? [anchorLine, headLine] : [headLine, anchorLine];
      const ideal = import_state.EditorSelection.range(startLine.from, endLine.to);
      let nextSel;
      if (ideal.from === initial.from && ideal.to === initial.to && view.state.doc.lines > endLine.number) {
        const nextLine = view.state.doc.line(endLine.number + 1);
        nextSel = import_state.EditorSelection.range(startLine.from, nextLine.to);
      } else {
        nextSel = import_state.EditorSelection.range(startLine.from, endLine.to);
      }
      view.dispatch({
        selection: nextSel
      });
      return true;
    },
    ["n"](view) {
      const register = view.state.field(searchRegisterField);
      const active = register.active;
      if (!(active == null ? void 0 : active.valid)) {
        if (active) {
          showSearchError(view, active);
        }
        return true;
      }
      const cursor = active.getCursor(view.state, view.state.selection.main.to);
      let match = cursor.next();
      if (match.done) {
        match = active.getCursor(view.state).next();
      }
      if (!match.done) {
        view.dispatch({
          selection: import_state.EditorSelection.range(match.value.from, match.value.to),
          scrollIntoView: true
        });
      }
    },
    ["N"](view) {
      const register = view.state.field(searchRegisterField);
      const active = register.active;
      if (!(active == null ? void 0 : active.valid)) {
        if (active) {
          showSearchError(view, active);
        }
        return true;
      }
      const cursor = active.getCursor(view.state);
      const selection = view.state.selection.main;
      let match;
      let before = false;
      for (const item of {
        [Symbol.iterator]() {
          return cursor;
        }
      }) {
        if (item.to < selection.from) {
          match = item;
          before = true;
        } else if (item.from > selection.to) {
          if (before) {
            break;
          } else {
            match = item;
          }
        }
      }
      if (match) {
        view.dispatch({
          selection: import_state.EditorSelection.range(match.from, match.to),
          scrollIntoView: true
        });
      }
    },
    ["Ctrl-d"](view, mode) {
      moveBy(view, mode, import_commands.cursorPageDown, import_commands.selectPageDown);
    },
    ["PageDown"]: "Ctrl-d",
    ["PageUp"]: "Ctrl-u",
    ["Ctrl-u"](view, mode) {
      moveBy(view, mode, import_commands.cursorPageUp, import_commands.selectPageUp);
    },
    [";"](view) {
      const selection = view.state.selection.main;
      view.dispatch({
        selection: import_state.EditorSelection.cursor(selection.head)
      });
    },
    ["Alt-;"](view) {
      const selection = view.state.selection.main;
      view.dispatch({
        selection: import_state.EditorSelection.range(selection.head, selection.anchor),
        scrollIntoView: true
      });
    },
    ["Alt-:"](view) {
      const selection = view.state.selection.main;
      view.dispatch({
        selection: import_state.EditorSelection.range(selection.from, selection.to)
      });
    },
    ["Alt-ArrowUp"](view) {
      return (0, import_commands.selectParentSyntax)(view);
    },
    ["Alt-o"]: "Alt-ArrowUp",
    ["Alt-ArrowRight"](view) {
      moveToSibling(view, true);
    },
    ["Alt-n"]: "Alt-ArrowRight",
    ["Alt-ArrowLeft"](view) {
      moveToSibling(view, false);
    },
    ["Alt-p"]: "Alt-ArrowLeft",
    ["Ctrl-c"]: {
      checkpoint: true,
      command(view) {
        (0, import_commands.toggleComment)(view);
        view.original.dispatch({
          effects: MODE_EFF.NORMAL
        });
      }
    },
    [">"]: {
      checkpoint: true,
      command(view) {
        return (0, import_commands.indentMore)(view);
      }
    },
    ["<"]: {
      checkpoint: true,
      command(view) {
        return (0, import_commands.indentLess)(view);
      }
    },
    ["`"]: {
      checkpoint: true,
      command(view) {
        changeCase(view, false);
      }
    },
    ["Alt-`"]: {
      checkpoint: true,
      command(view) {
        changeCase(view, true);
      }
    },
    ["~"]: {
      checkpoint: true,
      command(view) {
        changeCase(view);
      }
    },
    ["*"](view) {
      const selection = helixSelection(
        view.state.selection.main,
        view.state.doc
      );
      const selected = view.state.doc.slice(selection.from, selection.to).toString();
      view.dispatch({
        effects: searchEffect.of({
          type: 1,
          query: new import_search.SearchQuery({
            search: selected,
            caseSensitive: /[A-Z]/.test(selected),
            regexp: false
          })
        })
      });
    },
    ["_"](view) {
      const selection = helixSelection(
        view.state.selection.main,
        view.state.doc
      );
      const selected = view.state.doc.slice(selection.from, selection.to).toString();
      const trimmed = selected.trim();
      if (trimmed === selected) {
        return;
      }
      const startOffset = selected.indexOf(trimmed);
      const endOffset = selected.length - trimmed.length - startOffset;
      const anchor = selection.anchor === selection.from ? selection.anchor + startOffset : selection.anchor - endOffset;
      const head = selection.head === selection.to ? selection.head - endOffset : selection.head + startOffset;
      view.dispatch({
        selection: import_state.EditorSelection.range(anchor, head)
      });
    }
  },
  goto: {
    ["g"](view, mode) {
      const isNormal = mode.type === 0;
      isNormal ? (0, import_commands.cursorDocStart)(view) : (0, import_commands.selectDocStart)(view);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["e"](view, mode) {
      const isNormal = mode.type === 0;
      isNormal ? (0, import_commands.cursorDocEnd)(view) : (0, import_commands.selectDocEnd)(view);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["h"](view, mode) {
      const isNormal = mode.type === 0;
      isNormal ? (0, import_commands.cursorLineStart)(view) : (0, import_commands.selectLineStart)(view);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["j"](view, mode) {
      const isNormal = mode.type === 0;
      moveDown(view, mode);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["k"](view, mode) {
      const isNormal = mode.type === 0;
      moveUp(view, mode);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["l"](view, mode) {
      const isNormal = mode.type === 0;
      isNormal ? (0, import_commands.cursorLineBoundaryRight)(view) : (0, import_commands.selectLineBoundaryRight)(view);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    }
  },
  match: {
    ["s"]: {
      checkpoint: true,
      command(view, mode) {
        view.dispatch({
          effects: modeEffect.of({
            type: mode.type,
            minor: 5,
            expecting: {
              callback: surround,
              metadata: view
            }
          })
        });
        getHelixPanel(view.original, commandPanel).showMinor("ms");
      }
    },
    ["m"](view, mode) {
      var _a;
      const selection = (_a = matchBracket(view)) != null ? _a : void 0;
      const isNormal = mode.type === 0;
      view.dispatch({
        selection: (selection == null ? void 0 : selection.from) == null ? void 0 : isNormal ? import_state.EditorSelection.cursor(selection.from) : import_state.EditorSelection.range(
          view.state.selection.main.anchor,
          selection.from
        ),
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT,
        scrollIntoView: true
      });
    }
  },
  space: {
    ["y"](view) {
      const selection = view.state.selection.main;
      const range = helixSelection(selection, view.state.doc);
      navigator.clipboard.writeText(
        view.state.doc.slice(range.from, range.to).toString()
      );
      getHelixPanel(view, commandPanel).showMessage(
        "yanked 1 selection to register +"
      );
      view.dispatch({
        effects: MODE_EFF.NORMAL
      });
    },
    ["p"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        navigator.clipboard.readText().then((yanked) => paste(view, yanked, true, false));
      }
    },
    ["P"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        navigator.clipboard.readText().then((yanked) => paste(view, yanked, false, false));
      }
    },
    ["R"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        navigator.clipboard.readText().then((yanked) => {
          const tr = view.state.replaceSelection(yanked);
          view.dispatch(tr);
        });
      }
    }
  }
};
function paste(view, yanked, before, reset = true) {
  const range = view.state.selection.main;
  const spec = { from: range.to, insert: yanked };
  const change = view.state.changes(spec);
  view.dispatch(
    { changes: change },
    {
      selection: before ? { anchor: range.to, head: range.to + yanked.length } : { anchor: range.from, head: range.from + yanked.length },
      sequential: true
    },
    reset ? { effects: MODE_EFF.NORMAL } : {}
  );
}
function setFindMode(view, status, mode, metadata) {
  const effect = modeEffect.of({
    type: mode.type,
    minor: 2,
    expecting: {
      callback: findText,
      metadata
    }
  });
  const panel = getHelixPanel(view, commandPanel);
  panel.showMinor(status);
  view.dispatch({ effects: effect });
}
function helixSelection(range, doc) {
  const to = Math.min(range.to + 1, doc.length);
  const forward = range.head >= range.anchor;
  const anchor = forward ? range.anchor : to;
  const head = forward ? to : range.head;
  return import_state.EditorSelection.range(anchor, head);
}
function moveToSibling(view, forward) {
  const tree = (0, import_language.syntaxTree)(view.state);
  const selection = view.state.selection.main;
  let stack = tree.resolveStack(selection.from, 1);
  let sibling = null;
  while (true) {
    const node = stack.node;
    if (node && node.from <= selection.from && node.to >= selection.to) {
      sibling = forward ? node == null ? void 0 : node.nextSibling : node == null ? void 0 : node.prevSibling;
      if (sibling) {
        break;
      }
    }
    if (stack.next) {
      stack = stack.next;
    } else {
      break;
    }
  }
  if (!sibling) {
    view.dispatch({
      selection: import_state.EditorSelection.range(0, view.state.doc.length),
      scrollIntoView: true
    });
    return;
  }
  view.dispatch({
    selection: import_state.EditorSelection.range(sibling.from, sibling.to),
    scrollIntoView: true
  });
}
function insertLineAndEdit(view, below) {
  let from;
  let cursor;
  if (below) {
    const line = view.state.doc.lineAt(view.state.selection.main.to);
    from = line.to;
    cursor = from + 1;
  } else {
    const line = view.state.doc.lineAt(view.state.selection.main.from);
    from = line.from;
    cursor = from;
  }
  view.dispatch({
    changes: {
      from,
      insert: "\n"
    },
    selection: import_state.EditorSelection.cursor(cursor),
    effects: MODE_EFF.INSERT
  });
}
function toCodemirrorKeymap(keybindings) {
  const allKeys = [
    ...new Set(
      Object.values(keybindings).flat().flatMap((binding) => Object.keys(binding))
    )
  ];
  function apply(def, view, mode) {
    if (typeof def === "function") {
      return def(view, mode);
    } else {
      const temp = def.checkpoint === "temp";
      return def.command(
        {
          original: view,
          dispatch(...args) {
            view.dispatch(commitToHistory(view, temp), ...args);
          },
          get state() {
            return view.state;
          }
        },
        mode
      );
    }
  }
  function getExplicitCommand(key, bindings) {
    while (true) {
      const binding = bindings[key];
      if (typeof binding === "string") {
        key = binding;
        continue;
      }
      return binding;
    }
  }
  const codemirrorKeybindings = [];
  for (const key of allKeys) {
    const insertCommand = getExplicitCommand(key, keybindings.insert);
    const normalCommand = getExplicitCommand(key, keybindings.normal);
    const gotoCommand = getExplicitCommand(key, keybindings.goto);
    const matchCommand = getExplicitCommand(key, keybindings.match);
    const spaceCommand = getExplicitCommand(key, keybindings.space);
    const esc = key === "Escape";
    const isChar = key.length === 1;
    const command = (view) => {
      var _a;
      const mode = view.state.field(modeField);
      if (mode.type === 1) {
        if (insertCommand) {
          return (_a = insertCommand(view, void 0)) != null ? _a : true;
        } else {
          return false;
        }
      }
      if (mode.expecting && isChar) {
        return false;
      }
      let result;
      if (esc || mode.minor === 2 && normalCommand) {
        result = apply(normalCommand, view, mode);
      } else if (mode.minor === 3 && gotoCommand) {
        result = apply(gotoCommand, view, mode);
      } else if (mode.minor === 5 && matchCommand) {
        result = apply(matchCommand, view, mode);
      } else if (mode.minor === 6 && spaceCommand) {
        result = apply(spaceCommand, view, mode);
      } else {
        return false;
      }
      return result != null ? result : true;
    };
    codemirrorKeybindings.push({
      key,
      run: command
    });
  }
  return codemirrorKeybindings;
}
var EndLineCursor = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.classList.add("cm-hx-cursor");
    span.classList.add("cm-hx-cursor-endline");
    span.textContent = " ";
    return span;
  }
};
var cursorMark = import_view.Decoration.mark({ class: "cm-hx-cursor" });
var endlineCursorWidget = import_view.Decoration.widget({ widget: new EndLineCursor() });
var cursorField = import_state.StateField.define({
  create(state) {
    return drawCursorMark(state.selection, state.doc);
  },
  update(_value, tr) {
    return drawCursorMark(tr.newSelection, tr.newDoc);
  },
  provide(field) {
    return import_view.EditorView.decorations.from(field);
  }
});
function drawCursorMark(selection, doc) {
  const head = selection.main.head;
  const line = doc.lineAt(head);
  if (line.to === head) {
    return import_view.Decoration.set(
      endlineCursorWidget.range(selection.main.head, selection.main.head)
    );
  } else {
    return import_view.Decoration.set(
      cursorMark.range(selection.main.head, selection.main.head + 1)
    );
  }
}
function letThrough(tr) {
  return tr;
}
var changeFilter = import_state.EditorState.transactionFilter.from(
  modeField,
  (mode) => mode.type === 1 ? letThrough : (tr) => {
    const userEvent = tr.annotation(import_state.Transaction.userEvent);
    if (userEvent == null) {
      return tr;
    }
    if (!userEvent.startsWith("input")) {
      return tr;
    }
    if (userEvent === "input.type.compose.start") {
      return [];
    }
    if (!userEvent.startsWith("input.type")) {
      return tr;
    }
    if (mode.minor !== 2) {
      return {
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      };
    }
    return [];
  }
);
var inputHandler = import_view.EditorView.inputHandler.from(
  modeField,
  (mode) => (view, _from, _to, text) => {
    if (mode.type === 1) {
      return false;
    }
    if (mode.expecting) {
      mode.expecting.callback(view, text, mode.expecting.metadata);
      return true;
    }
    return false;
  }
);
var updateListener = import_view.EditorView.updateListener.of((viewUpdate) => {
  const { state, startState } = viewUpdate;
  const panel = getHelixPanel(viewUpdate.view, statusPanel);
  const mode = state.field(modeField);
  const startMode = startState.field(modeField);
  if (mode !== startMode) {
    const startExternalMode = toExternalMode(startMode);
    const externalMode = toExternalMode(mode);
    if (startExternalMode !== externalMode) {
      panel.setMode(externalMode);
    }
  }
  panel.setLineCol();
});
var helixKeymap = import_view.keymap.of(toCodemirrorKeymap(helixCommandBindings));
var commandFacet = import_state.Facet.define({
  combine(commands) {
    return commands.flat();
  }
});
function helix(options = {}) {
  return [
    import_view.EditorView.theme({
      ".cm-hx-block-cursor .cm-cursor": {
        display: "none !important"
      },
      ".cm-hx-block-cursor .cm-hx-cursor": {
        background: "#ccc"
      },
      // WARNING: flaky
      ".cm-searchMatch": {
        background: "initial"
      }
    }),
    panelStyles,
    (0, import_view.drawSelection)({
      cursorBlinkRate: 0
    }),
    helixKeymap,
    modeField,
    historyField,
    registerField,
    searchRegisterField,
    changeFilter,
    inputHandler,
    cursorField,
    updateListener,
    import_view.showPanel.of(statusPanel),
    import_view.showPanel.of(commandPanel),
    (0, import_search.search)(),
    import_view.ViewPlugin.define((view) => {
      const cursorShape = options["editor.cursor-shape.insert"];
      view.scrollDOM.classList.add("cm-hx-block-cursor");
      return {
        update(update) {
          const mode = update.state.field(modeField);
          const startMode = update.startState.field(modeField);
          const panel = getHelixPanel(view, commandPanel);
          if (panel.hasMessage() && update.docChanged || update.selectionSet) {
            panel.clearMessage();
          }
          const modeChanged = !sameMode(mode, startMode);
          if (modeChanged && mode.type !== 1 && mode.minor === 2) {
            panel.showMinor(null);
          }
          if (modeChanged && cursorShape === "bar") {
            if (mode.type === 1) {
              view.scrollDOM.classList.remove("cm-hx-block-cursor");
            } else {
              view.scrollDOM.classList.add("cm-hx-block-cursor");
            }
          }
        }
      };
    }),
    commandFacet.of([
      {
        name: "goto",
        aliases: ["g"],
        help: "Goto line number",
        handler(view, args) {
          if (args.length === 0) {
            return { message: "Line number required", error: true };
          }
          const lineNo = Number(args[0]);
          if (!Number.isFinite(lineNo) || lineNo <= 0) {
            return { message: "Invalid line number", error: true };
          }
          const effectiveLine = Math.min(lineNo, view.state.doc.lines);
          const line = view.state.doc.line(effectiveLine);
          view.dispatch({
            selection: import_state.EditorSelection.cursor(line.from),
            scrollIntoView: true
          });
        }
      },
      {
        name: "clipboard-yank",
        help: "Yank main selection into system clipboard",
        handler(view) {
          const selection = view.state.selection.main;
          const range = helixSelection(selection, view.state.doc);
          navigator.clipboard.writeText(
            view.state.doc.slice(range.from, range.to).toString()
          );
          return { message: "Yanked main selection to + register" };
        }
      }
    ])
  ];
}
function commandPanel(view) {
  return new CommandPanel(view, commandFacet, addSearch);
}
function getHelixPanel(view, panel) {
  return (0, import_view.getPanel)(view, panel);
}
function toExternalMode(mode) {
  switch (mode.type) {
    case 0:
      return "NOR";
    case 4:
      return "SEL";
    case 1:
      return "INS";
  }
}
function findText(view, text, {
  inclusive,
  reverse
}) {
  const mode = view.state.field(modeField);
  const select = mode.type === 4;
  const selection = view.state.selection.main;
  const start = selection.head;
  const doc = view.state.doc.toString();
  const rawIndex = reverse ? doc.lastIndexOf(text, start - 1) : doc.indexOf(text, start + 1);
  const resetEffect = select ? MODE_EFF.SELECT : MODE_EFF.NORMAL;
  const panel = getHelixPanel(view, commandPanel);
  if (rawIndex === -1) {
    view.dispatch({
      effects: resetEffect
    });
    panel.showMinor(null);
    return;
  }
  const index = inclusive ? rawIndex : reverse ? rawIndex + 1 : rawIndex - 1;
  const newSelection = select ? import_state.EditorSelection.range(selection.anchor, index) : import_state.EditorSelection.range(selection.head, index);
  view.dispatch({
    effects: resetEffect,
    selection: newSelection
  });
  panel.showMinor(null);
}
var PAIRS = {
  "(": ["(", ")", true],
  ")": ["(", ")", false],
  "{": ["{", "}", true],
  "}": ["{", "}", false],
  "[": ["[", "]", true],
  "]": ["[", "]", false],
  "<": ["<", ">", true],
  ">": ["<", ">", false]
};
var MATCHEABLE = /* @__PURE__ */ new Set([...Object.keys(PAIRS), `"`, "'"]);
function matchBracket(view) {
  var _a, _b;
  const selection = view.state.selection.main;
  const char = view.state.doc.slice(selection.head, selection.head + 1).toString();
  if (!MATCHEABLE.has(char)) {
    return null;
  }
  const open = (_b = (_a = PAIRS[char]) == null ? void 0 : _a[2]) != null ? _b : false;
  const match = (0, import_language.matchBrackets)(
    view.state,
    selection.head + (open ? 0 : 1),
    open ? 1 : -1
  );
  if (match) {
    return match.end;
  }
}
function surround(view, char, proxy) {
  var _a, _b;
  const pair = PAIRS[char];
  const selection = view.state.selection.main;
  const range = helixSelection(selection, view.state.doc);
  const open = (_a = pair == null ? void 0 : pair[0]) != null ? _a : char;
  const close = (_b = pair == null ? void 0 : pair[1]) != null ? _b : char;
  view.dispatch({
    changes: [
      {
        from: range.from,
        insert: open
      },
      {
        from: range.to,
        insert: close
      }
    ],
    effects: MODE_EFF.NORMAL
  });
  const newSelection = proxy.original.state.selection.main;
  const offset = newSelection.anchor === newSelection.from ? 1 : -1;
  const anchor = newSelection.anchor - offset;
  const head = newSelection.head + offset;
  proxy.original.dispatch({
    selection: import_state.EditorSelection.range(anchor, head)
  });
}
function commitToHistory(view, temp = false) {
  return {
    effects: historyEffect.of({
      type: "add",
      state: view.state,
      temp
    })
  };
}
function changeCase(view, upper) {
  const selection = view.state.selection.main;
  const selected = view.state.doc.slice(selection.from, selection.to);
  let insert;
  if (upper == null) {
    insert = [...selected.toString()].map((char) => {
      let next = char.toUpperCase();
      return next === char ? char.toLowerCase() : next;
    }).join("");
  } else if (upper) {
    insert = selected.toString().toUpperCase();
  } else {
    insert = selected.toString().toLowerCase();
  }
  view.dispatch({
    changes: {
      from: selection.from,
      to: selection.to,
      insert
    }
  });
}
function replaceWithChar(view, char, viewProxy) {
  const selection = view.state.selection.main;
  const selected = view.state.doc.slice(selection.from, selection.to);
  viewProxy.dispatch({
    changes: {
      from: selection.from,
      to: selection.to,
      insert: selected.toString().replace(/[^\n]/g, char)
    },
    effects: MODE_EFF.NORMAL
  });
  getHelixPanel(view, commandPanel).showMinor(null);
}
function showSearchError(view, query) {
  let message = "";
  try {
    query.getCursor(view.state);
  } catch (error) {
    message = error == null ? void 0 : error.message;
  }
  getHelixPanel(view, commandPanel).showMessage(
    `Invalid regex /${query.search}/: ${message}`,
    true
  );
}

// main.ts
var DEFAULT_SETTINGS = {
  enableHelixKeybindings: false,
  // Following the defualt Obsidian behavior, instead of the Helix one.
  cursorInInsertMode: "bar"
};
var HelixPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.extensions = [];
    this.addSettingTab(new HelixSettingsTab(this.app, this));
    this.setEnabled(this.settings.enableHelixKeybindings, false);
    this.registerEditorExtension(this.extensions);
    this.addCommand({
      id: "toggle-helix-keybindings",
      name: "Toggle Helix keybindings",
      callback: async () => this.setEnabled(!this.settings.enableHelixKeybindings, true, true)
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async setEnabled(value, reload = true, print = false) {
    this.settings.enableHelixKeybindings = value;
    this.extensions.length = 0;
    if (value)
      this.extensions.push(helix({
        "editor.cursor-shape.insert": this.settings.cursorInInsertMode
      }));
    await this.saveSettings();
    if (reload)
      this.app.workspace.updateOptions();
    if (print) {
      const msg = value ? "Enabled" : "Disabled";
      new import_obsidian.Notice(`${msg} Helix keybindings`);
    }
  }
  async reload() {
    await this.setEnabled(this.settings.enableHelixKeybindings);
  }
};
var HelixSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("p", { text: "Vim keybindings must be disabled for the plugin to work" });
    new import_obsidian.Setting(containerEl).setName("Enable Helix keybindings").addToggle(async (value) => {
      value.setValue(this.plugin.settings.enableHelixKeybindings).onChange(async (value2) => this.plugin.setEnabled(value2));
    });
    new import_obsidian.Setting(containerEl).setName("Cursor in insert mode").addDropdown((dropDown) => {
      dropDown.addOption("block", "Block");
      dropDown.addOption("bar", "Bar");
      dropDown.setValue(this.plugin.settings.cursorInInsertMode);
      dropDown.onChange(async (value) => {
        if (value == "block" || value == "bar") {
          this.plugin.settings.cursorInInsertMode = value;
          await this.plugin.saveSettings();
          await this.plugin.reload();
        }
      });
    });
  }
};
